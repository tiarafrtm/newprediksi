{"file_contents":{"main.py":{"content":"\"\"\"\nMain application entry point using Flask app factory pattern\n\"\"\"\nfrom app import create_app\nfrom app.services.ml_service import ml_service\n\n# Create Flask application\napp = create_app()\n\nif __name__ == '__main__':\n    # Initialize ML model on startup\n    ml_service.load_model()\n    app.run(host='0.0.0.0', port=5000, debug=False)","size_bytes":334},"pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"email-validator>=2.3.0\",\n    \"flask-sqlalchemy>=3.1.1\",\n    \"flask>=3.1.2\",\n    \"google-genai>=1.38.0\",\n    \"gunicorn>=23.0.0\",\n    \"numpy>=2.3.3\",\n    \"pandas>=2.3.2\",\n    \"pillow>=11.3.0\",\n    \"pydantic>=2.11.9\",\n    \"python-dotenv>=1.1.1\",\n    \"requests>=2.32.5\",\n    \"scikit-learn>=1.7.2\",\n    \"sift-stack-py>=0.9.1\",\n    \"werkzeug>=3.1.3\",\n    \"psycopg2-binary>=2.9.10\",\n]\n","size_bytes":525},"app/__init__.py":{"content":"import os\nfrom flask import Flask\nfrom werkzeug.middleware.proxy_fix import ProxyFix\nfrom dotenv import load_dotenv\n\ndef create_app():\n    \"\"\"Flask application factory\"\"\"\n    load_dotenv()\n    \n    # Configure Flask to use templates and static files from root directory\n    app = Flask(__name__, \n                template_folder='../templates',\n                static_folder='../static')\n    from app.config import Config\n    app.secret_key = Config.SECRET_KEY\n    \n    # Configure ProxyFix for Replit environment\n    app.wsgi_app = ProxyFix(app.wsgi_app, x_proto=1, x_host=1)\n    \n    app.config['UPLOAD_FOLDER'] = 'static/images'\n    app.config['MAX_CONTENT_LENGTH'] = 16 * 1024 * 1024  # 16MB max file size\n    \n    # Ensure required directories exist\n    os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)\n    os.makedirs('data', exist_ok=True)\n    os.makedirs('models', exist_ok=True)\n    \n    # Register blueprints\n    from app.blueprints.main import main_bp\n    from app.blueprints.admin import admin_bp\n    from app.blueprints.api import api_bp\n    \n    app.register_blueprint(main_bp)\n    app.register_blueprint(admin_bp, url_prefix='/admin')\n    app.register_blueprint(api_bp, url_prefix='/api')\n    \n    return app","size_bytes":1230},"app/config.py":{"content":"import os\nfrom dotenv import load_dotenv\n\n# Load environment variables\nload_dotenv()\n\nclass Config:\n    \"\"\"Application configuration\"\"\"\n    SECRET_KEY = os.getenv('SESSION_SECRET')\n    if not SECRET_KEY or SECRET_KEY == 'your_session_secret_here_change-this-to-random-string':\n        SECRET_KEY = 'dev-secret-key-change-in-production'  # Fallback for development\n\n    UPLOAD_FOLDER = 'static/images'\n    MAX_CONTENT_LENGTH = 16 * 1024 * 1024  # 16MB max file size\n\n    # ML Model configuration\n    FEATURE_COLUMNS = [\n        'luas_tanah', 'luas_bangunan', 'kamar_tidur', 'kamar_mandi', \n        'carport', 'tahun_dibangun', 'lantai', 'jarak_sekolah', 'jarak_rs', \n        'jarak_pasar', 'jenis_jalan_encoded', 'kondisi_encoded', 'sertifikat_encoded'\n    ]\n\n    # Gemini AI configuration\n    GEMINI_API_KEY = os.getenv('GEMINI_API_KEY')\n\n    # Google Maps configuration\n    GOOGLE_MAPS_API_KEY = os.getenv('GOOGLE_MAPS_API_KEY')\n\n    # Encoding mappings for categorical variables\n    JENIS_JALAN_MAP = {'gang_kecil': 1, 'jalan_sedang': 2, 'jalan_besar': 3}\n    KONDISI_MAP = {'butuh_renovasi': 1, 'renovasi_ringan': 2, 'baik': 3, 'baru': 4}\n    SERTIFIKAT_MAP = {'girik': 1, 'hgb': 2, 'shm': 3}\n\n    # Prabumulih-specific area mappings\n    AREA_MAP = {\n        'pusat_kota': 4,        # Pusat Kota Prabumulih\n        'karang_raja': 3,       # Karang Raja\n        'gunung_ibul': 3,       # Gunung Ibul  \n        'rambutan': 2,          # Rambutan\n        'tanjung_api': 2,       # Tanjung Api\n        'cambai': 1             # Cambai\n    }\n\n    # Regional price factors for Prabumulih\n    PRABUMULIH_PRICE_FACTORS = {\n        'coal_proximity_bonus': 0.1,    # Bonus jika dekat area pertambangan\n        'city_center_multiplier': 1.3,   # Multiplier untuk pusat kota\n        'education_facility_bonus': 0.05  # Bonus fasilitas pendidikan\n    }","size_bytes":1842},"app/models.py":{"content":"import json\nimport os\nfrom typing import List, Dict, Optional\nfrom app.config import Config\n\nclass PropertyRepository:\n    \"\"\"Handle property data operations\"\"\"\n    \n    @staticmethod\n    def load_properties() -> List[Dict]:\n        \"\"\"Load properties from JSON file\"\"\"\n        try:\n            with open('data/properties.json', 'r') as f:\n                return json.load(f)\n        except FileNotFoundError:\n            return []\n    \n    @staticmethod\n    def save_properties(properties: List[Dict]) -> None:\n        \"\"\"Save properties to JSON file\"\"\"\n        with open('data/properties.json', 'w') as f:\n            json.dump(properties, f, indent=2)\n    \n    @staticmethod\n    def get_property_by_id(property_id: str) -> Optional[Dict]:\n        \"\"\"Get property by ID\"\"\"\n        properties = PropertyRepository.load_properties()\n        return next((p for p in properties if p['id'] == property_id), None)\n    \n    @staticmethod\n    def add_property(property_data: Dict) -> None:\n        \"\"\"Add new property\"\"\"\n        properties = PropertyRepository.load_properties()\n        properties.append(property_data)\n        PropertyRepository.save_properties(properties)\n    \n    @staticmethod\n    def update_property(property_id: str, updated_data: Dict) -> bool:\n        \"\"\"Update existing property\"\"\"\n        properties = PropertyRepository.load_properties()\n        for i, property_data in enumerate(properties):\n            if property_data['id'] == property_id:\n                # Keep the original ID and created_at\n                updated_data['id'] = property_id\n                if 'created_at' not in updated_data and 'created_at' in property_data:\n                    updated_data['created_at'] = property_data['created_at']\n                properties[i] = updated_data\n                PropertyRepository.save_properties(properties)\n                return True\n        return False\n\n    @staticmethod\n    def delete_property(property_id: str) -> bool:\n        \"\"\"Delete property by ID\"\"\"\n        properties = PropertyRepository.load_properties()\n        original_count = len(properties)\n        properties = [p for p in properties if p['id'] != property_id]\n        \n        if len(properties) < original_count:\n            PropertyRepository.save_properties(properties)\n            return True\n        return False\n\ndef encode_categorical(value: str, mapping: Dict[str, int]) -> int:\n    \"\"\"Encode categorical values using provided mapping\"\"\"\n    return mapping.get(value, 0)\n\nclass BasePriceRepository:\n    \"\"\"Handle base price settings for predictions\"\"\"\n    \n    @staticmethod\n    def load_base_prices() -> Dict:\n        \"\"\"Load base price settings from JSON file\"\"\"\n        try:\n            with open('data/base_prices.json', 'r') as f:\n                return json.load(f)\n        except FileNotFoundError:\n            # Default base prices\n            default_prices = {\n                'base_price_per_sqm_land': 500000,  # Rp per m2 tanah\n                'base_price_per_sqm_building': 2000000,  # Rp per m2 bangunan\n                'room_multiplier': 50000000,  # Bonus per kamar\n                'bathroom_multiplier': 25000000,  # Bonus per kamar mandi\n                'floor_multiplier': 10000000,  # Bonus per lantai\n                'carport_multiplier': 15000000,  # Bonus per carport\n                'year_bonus_per_year': 2000000,  # Bonus per tahun setelah 2000\n                'condition_multipliers': {\n                    'baru': 1.3,\n                    'baik': 1.0,\n                    'renovasi_ringan': 0.8,\n                    'butuh_renovasi': 0.6\n                },\n                'road_multipliers': {\n                    'jalan_besar': 1.2,\n                    'jalan_sedang': 1.0,\n                    'gang_kecil': 0.8\n                },\n                'certificate_multipliers': {\n                    'shm': 1.1,\n                    'hgb': 1.0,\n                    'girik': 0.9\n                }\n            }\n            BasePriceRepository.save_base_prices(default_prices)\n            return default_prices\n    \n    @staticmethod\n    def save_base_prices(base_prices: Dict) -> bool:\n        \"\"\"Save base price settings to JSON file\"\"\"\n        try:\n            # Ensure the data directory exists\n            os.makedirs('data', exist_ok=True)\n            \n            with open('data/base_prices.json', 'w') as f:\n                json.dump(base_prices, f, indent=2)\n            return True\n        except Exception as e:\n            print(f\"Error saving base prices: {e}\")\n            return False\n    \n    @staticmethod\n    def update_base_prices(updated_data: Dict) -> bool:\n        \"\"\"Update base price settings\"\"\"\n        try:\n            current_prices = BasePriceRepository.load_base_prices()\n            current_prices.update(updated_data)\n            BasePriceRepository.save_base_prices(current_prices)\n            return True\n        except Exception as e:\n            print(f\"Error updating base prices: {e}\")\n            return False","size_bytes":4986},"app/blueprints/__init__.py":{"content":"# Blueprints package","size_bytes":20},"app/blueprints/admin.py":{"content":"import uuid\nimport os\nfrom datetime import datetime\nfrom flask import Blueprint, render_template, request, redirect, url_for, flash, current_app\nfrom werkzeug.utils import secure_filename\nfrom app.models import PropertyRepository\nfrom app.services.ml_service import ml_service\nimport re\n\ndef _parse_price(price_str):\n    \"\"\"Parse price string with robust regex to remove all non-digits\"\"\"\n    if not price_str:\n        return None\n    try:\n        # Remove all non-digit characters using regex\n        cleaned = re.sub(r\"[^0-9]\", \"\", str(price_str))\n        return int(cleaned) if cleaned else None\n    except (ValueError, AttributeError):\n        return None\n\nadmin_bp = Blueprint('admin', __name__)\n\n@admin_bp.route('/')\ndef admin_panel():\n    \"\"\"Admin panel dashboard\"\"\"\n    properties = PropertyRepository.load_properties()\n    return render_template('admin/dashboard.html', properties=properties)\n\n@admin_bp.route('/properties')\ndef properties():\n    \"\"\"Properties management page\"\"\"\n    properties = PropertyRepository.load_properties()\n    return render_template('admin/properties.html', properties=properties)\n\n@admin_bp.route('/add_property', methods=['POST'])\ndef add_property():\n    \"\"\"Add new property\"\"\"\n    try:\n        # Handle multiple file uploads\n        image_filenames = []\n        if 'images' in request.files:\n            files = request.files.getlist('images')\n            for file in files:\n                if file and file.filename:\n                    filename = secure_filename(file.filename)\n                    image_filename = f\"{uuid.uuid4()}_{filename}\"\n                    file.save(os.path.join(current_app.config['UPLOAD_FOLDER'], image_filename))\n                    image_filenames.append(image_filename)\n        \n        # Backward compatibility: check for single image upload\n        if 'image' in request.files and not image_filenames:\n            file = request.files['image']\n            if file and file.filename:\n                filename = secure_filename(file.filename)\n                image_filename = f\"{uuid.uuid4()}_{filename}\"\n                file.save(os.path.join(current_app.config['UPLOAD_FOLDER'], image_filename))\n                image_filenames.append(image_filename)\n\n        # Create property data\n        property_data = {\n            'id': str(uuid.uuid4()),\n            'judul_properti': request.form.get('judul_properti'),\n            'kelurahan': request.form.get('kelurahan'),\n            'kecamatan': request.form.get('kecamatan'),\n            'alamat': request.form.get('alamat'),\n            'deskripsi': request.form.get('deskripsi', ''),\n            'luas_tanah': int(request.form.get('luas_tanah') or 0),\n            'luas_bangunan': int(request.form.get('luas_bangunan') or 0),\n            'kamar_tidur': int(request.form.get('kamar_tidur') or 2),\n            'kamar_mandi': int(request.form.get('kamar_mandi') or 1),\n            'carport': int(request.form.get('carport', 0) or 0),\n            'tahun_dibangun': int(request.form.get('tahun_dibangun') or 2020),\n            'lantai': int(request.form.get('lantai', 1) or 1),\n            'kota': request.form.get('kota'),\n            'harga': _parse_price(request.form.get('harga')),\n            'latitude': float(request.form.get('latitude') or 0) if request.form.get('latitude') else None,\n            'longitude': float(request.form.get('longitude') or 0) if request.form.get('longitude') else None,\n            'jarak_sekolah': float(request.form.get('jarak_sekolah', 1000) or 1000),\n            'jarak_rs': float(request.form.get('jarak_rs', 2000) or 2000),\n            'jarak_pasar': float(request.form.get('jarak_pasar', 1500) or 1500),\n            'jenis_jalan': request.form.get('jenis_jalan'),\n            'kondisi': request.form.get('kondisi'),\n            'sertifikat': request.form.get('sertifikat'),\n            'nama_penjual': request.form.get('nama_penjual', ''),\n            'nomor_penjual': request.form.get('nomor_penjual', ''),\n            'images': image_filenames,\n            'image': image_filenames[0] if image_filenames else None,  # Backward compatibility\n            'created_at': datetime.now().isoformat(),\n            'status': 'available'\n        }\n\n        # Save property\n        PropertyRepository.add_property(property_data)\n\n        # Retrain ML model with new data\n        ml_service.train_model()\n\n        flash('Property added successfully!')\n\n    except Exception as e:\n        flash(f'Error adding property: {str(e)}')\n\n    return redirect(url_for('admin.admin_panel'))\n\n@admin_bp.route('/edit_property/<property_id>')\ndef edit_property(property_id):\n    \"\"\"Show edit property form\"\"\"\n    property_data = PropertyRepository.get_property_by_id(property_id)\n    if not property_data:\n        flash('Property not found')\n        return redirect(url_for('admin.admin_panel'))\n\n    return render_template('admin/edit_property.html', property=property_data)\n\n@admin_bp.route('/update_property/<property_id>', methods=['POST'])\ndef update_property(property_id):\n    \"\"\"Update existing property\"\"\"\n    try:\n        property_data = PropertyRepository.get_property_by_id(property_id)\n        if not property_data:\n            flash('Property not found')\n            return redirect(url_for('admin.admin_panel'))\n\n        # Handle multiple file uploads\n        existing_images = property_data.get('images', [])\n        if not existing_images and property_data.get('image'):\n            # Convert old single image to array format\n            existing_images = [property_data.get('image')]\n        \n        image_filenames = existing_images.copy()  # Keep existing images by default\n        \n        if 'images' in request.files:\n            files = request.files.getlist('images')\n            new_images = []\n            for file in files:\n                if file and file.filename:\n                    filename = secure_filename(file.filename)\n                    image_filename = f\"{uuid.uuid4()}_{filename}\"\n                    file.save(os.path.join(current_app.config['UPLOAD_FOLDER'], image_filename))\n                    new_images.append(image_filename)\n            \n            # If new images uploaded, replace all images\n            if new_images:\n                image_filenames = new_images\n        \n        # Backward compatibility: check for single image upload\n        elif 'image' in request.files:\n            file = request.files['image']\n            if file and file.filename:\n                filename = secure_filename(file.filename)\n                image_filename = f\"{uuid.uuid4()}_{filename}\"\n                file.save(os.path.join(current_app.config['UPLOAD_FOLDER'], image_filename))\n                image_filenames = [image_filename]\n\n        # Create updated property data\n        updated_data = {\n            'judul_properti': request.form.get('judul_properti'),\n            'kelurahan': request.form.get('kelurahan'),\n            'kecamatan': request.form.get('kecamatan'),\n            'alamat': request.form.get('alamat'),\n            'deskripsi': request.form.get('deskripsi', ''),\n            'luas_tanah': int(request.form.get('luas_tanah') or 0),\n            'luas_bangunan': int(request.form.get('luas_bangunan') or 0),\n            'kamar_tidur': int(request.form.get('kamar_tidur') or 2),\n            'kamar_mandi': int(request.form.get('kamar_mandi') or 1),\n            'carport': int(request.form.get('carport', 0) or 0),\n            'tahun_dibangun': int(request.form.get('tahun_dibangun') or 2020),\n            'lantai': int(request.form.get('lantai', 1) or 1),\n            'kota': request.form.get('kota'),\n            'harga': _parse_price(request.form.get('harga')),\n            'latitude': float(request.form.get('latitude') or 0) if request.form.get('latitude') else None,\n            'longitude': float(request.form.get('longitude') or 0) if request.form.get('longitude') else None,\n            'jarak_sekolah': float(request.form.get('jarak_sekolah', 1000) or 1000),\n            'jarak_rs': float(request.form.get('jarak_rs', 2000) or 2000),\n            'jarak_pasar': float(request.form.get('jarak_pasar', 1500) or 1500),\n            'jenis_jalan': request.form.get('jenis_jalan'),\n            'kondisi': request.form.get('kondisi'),\n            'sertifikat': request.form.get('sertifikat'),\n            'nama_penjual': request.form.get('nama_penjual', ''),\n            'nomor_penjual': request.form.get('nomor_penjual', ''),\n            'images': image_filenames,\n            'image': image_filenames[0] if image_filenames else None,  # Backward compatibility\n            'status': request.form.get('status', 'available')\n        }\n\n        # Update property\n        if PropertyRepository.update_property(property_id, updated_data):\n            # Retrain ML model with updated data\n            ml_service.train_model()\n            flash('Property updated successfully!')\n        else:\n            flash('Failed to update property')\n\n    except Exception as e:\n        flash(f'Error updating property: {str(e)}')\n\n    return redirect(url_for('main.property_detail', property_id=property_id))\n\n@admin_bp.route('/delete_property/<property_id>')\ndef delete_property(property_id):\n    \"\"\"Delete property\"\"\"\n    if PropertyRepository.delete_property(property_id):\n        # Retrain model\n        ml_service.train_model()\n        flash('Property deleted successfully!')\n    else:\n        flash('Property not found')\n\n    return redirect(url_for('admin.admin_panel'))\n\n\n\n@admin_bp.route('/settings')\ndef settings():\n    \"\"\"Admin settings page\"\"\"\n    return render_template('admin/settings.html')","size_bytes":9588},"app/blueprints/api.py":{"content":"from flask import Blueprint, jsonify, request\nfrom app.models import PropertyRepository\nfrom app.services.ai_service import AIPropertySearch\nfrom app.services.ml_service import ml_service\n\napi_bp = Blueprint('api', __name__)\n\n@api_bp.route('/properties')\ndef get_properties():\n    \"\"\"API endpoint for properties\"\"\"\n    properties = PropertyRepository.load_properties()\n    return jsonify(properties)\n\n@api_bp.route('/search_properties', methods=['POST'])\ndef search_properties():\n    \"\"\"Enhanced AI-powered property search with deterministic filtering\"\"\"\n    try:\n        data = request.get_json()\n        query = data.get('query', '').strip()\n        \n        print(f\"Search query received: {query}\")  # Debug log\n        \n        if not query:\n            response_data = {\n                'properties': PropertyRepository.load_properties()[:6],\n                'explanation': 'Menampilkan beberapa properti terbaru.',\n                'ai_powered': False\n            }\n        else:\n            # Use the new AI search service\n            response_data = AIPropertySearch.search_properties(query)\n        \n        # Create response with no-cache headers\n        response = jsonify(response_data)\n        response.headers['Cache-Control'] = 'no-cache, no-store, must-revalidate, max-age=0'\n        response.headers['Pragma'] = 'no-cache'\n        response.headers['Expires'] = '0'\n        \n        return response\n        \n    except Exception as e:\n        print(f\"Search error: {str(e)}\")  # Debug log\n        # Fallback to basic properties on error\n        error_response = {\n            'properties': PropertyRepository.load_properties()[:5],\n            'explanation': 'Terjadi kesalahan dalam pencarian. Menampilkan properti terbaru.',\n            'ai_powered': False,\n            'error': str(e)\n        }\n        response = jsonify(error_response)\n        response.headers['Cache-Control'] = 'no-cache, no-store, must-revalidate'\n        return response\n\n@api_bp.route('/predict', methods=['POST'])\ndef predict_price():\n    \"\"\"API endpoint for price prediction with similar properties\"\"\"\n    try:\n        data = request.get_json()\n        \n        # Log input data for debugging\n        print(f\"Prediction input received: {data}\")\n        print(f\"Input keys: {list(data.keys()) if data else 'No data'}\")\n        print(f\"Input values: {list(data.values()) if data else 'No values'}\")\n        \n        # Get price prediction\n        predicted_price = ml_service.predict_price(data)\n        \n        if predicted_price:\n            # Calculate price range (±20% from predicted)\n            variation = predicted_price * 0.2\n            price_range = {\n                'min_price': max(0, predicted_price - variation),\n                'max_price': predicted_price + variation,\n                'predicted_price': predicted_price,\n                'formatted': f\"Rp {predicted_price:,.0f}\".replace(',', '.')\n            }\n            \n            # Find similar properties within 30% of predicted price\n            all_properties = PropertyRepository.load_properties()\n            similar_properties = []\n            price_tolerance = predicted_price * 0.3  # 30% tolerance\n            min_similar_price = predicted_price - price_tolerance\n            max_similar_price = predicted_price + price_tolerance\n            \n            for prop in all_properties:\n                if prop.get('harga') and prop.get('status') == 'available':\n                    prop_price = float(prop['harga'])\n                    if min_similar_price <= prop_price <= max_similar_price:\n                        similar_properties.append(prop)\n            \n            # Sort by price difference and limit to 6 properties\n            similar_properties.sort(key=lambda p: abs(float(p['harga']) - predicted_price))\n            similar_properties = similar_properties[:6]\n            \n            response_data = {\n                'success': True,\n                'prediction': price_range,\n                'similar_properties': similar_properties,\n                'formatted': price_range['formatted'],\n                'timestamp': request.args.get('t', '')  # Include timestamp for debugging\n            }\n            \n            print(f\"Prediction result: {predicted_price:,.0f}\")  # Debug log\n            \n            # Create response with no-cache headers\n            response = jsonify(response_data)\n            response.headers['Cache-Control'] = 'no-cache, no-store, must-revalidate'\n            response.headers['Pragma'] = 'no-cache'\n            response.headers['Expires'] = '0'\n            \n            return response\n        else:\n            return jsonify({'success': False, 'error': 'Unable to predict price'})\n    \n    except Exception as e:\n        print(f\"Prediction error: {str(e)}\")  # Debug log\n        return jsonify({'success': False, 'error': str(e)})\ndef predict_price():\n    \"\"\"API endpoint for price prediction\"\"\"\n    try:\n        data = request.get_json()\n        prediction = ml_service.predict_price(data)\n        \n        if prediction:\n            return jsonify({\n                'prediction': prediction, \n                'formatted': f\"Rp {prediction:,.0f}\"\n            })\n        else:\n            return jsonify({\n                'error': 'Cannot predict price with current data. Please check if all required fields are provided.'\n            }), 400\n    except Exception as e:\n        return jsonify({\n            'error': f'Prediction failed: {str(e)}'\n        }), 500","size_bytes":5490},"app/blueprints/main.py":{"content":"from flask import Blueprint, render_template, request, redirect, url_for, flash\nfrom app.models import PropertyRepository\nfrom app.services.ai_service import gemini_chat_response\nfrom app.services.ml_service import ml_service\n\nmain_bp = Blueprint('main', __name__)\n\n@main_bp.route('/')\ndef index():\n    \"\"\"Homepage with search functionality\"\"\"\n    properties = PropertyRepository.load_properties()\n    featured_properties = properties[:6]  # Show first 6 as featured\n    return render_template('index.html', properties=featured_properties)\n\n@main_bp.route('/properties')\ndef properties():\n    \"\"\"Property listings page\"\"\"\n    properties = PropertyRepository.load_properties()\n    \n    # Apply filters\n    budget_min = request.args.get('budget_min', type=int)\n    budget_max = request.args.get('budget_max', type=int)\n    kecamatan = request.args.get('kecamatan', type=str)\n    \n    filtered_properties = properties\n    if budget_min:\n        filtered_properties = [p for p in filtered_properties if p.get('harga', 0) >= budget_min]\n    if budget_max:\n        filtered_properties = [p for p in filtered_properties if p.get('harga', 0) <= budget_max]\n    if kecamatan:\n        filtered_properties = [p for p in filtered_properties if p.get('kecamatan', '').strip().lower() == kecamatan.strip().lower()]\n    \n    return render_template('properties.html', properties=filtered_properties)\n\n@main_bp.route('/property/<property_id>')\ndef property_detail(property_id):\n    \"\"\"Property detail page\"\"\"\n    property_data = PropertyRepository.get_property_by_id(property_id)\n    \n    if not property_data:\n        flash('Property not found')\n        return redirect(url_for('main.properties'))\n    \n    # Get similar properties\n    all_properties = PropertyRepository.load_properties()\n    similar_properties = [p for p in all_properties if p['id'] != property_id][:3]\n    \n    return render_template('property_detail.html', property=property_data, similar_properties=similar_properties)\n\n@main_bp.route('/predict', methods=['GET', 'POST'])\ndef predict():\n    \"\"\"Property price prediction page\"\"\"\n    price_range = None\n    similar_properties = []\n    \n    if request.method == 'POST':\n        # Get form data\n        property_data = {\n            'luas_tanah': float(request.form.get('luas_tanah', 0)),\n            'luas_bangunan': float(request.form.get('luas_bangunan', 0)),\n            'kamar_tidur': int(request.form.get('kamar_tidur', 2)),\n            'kamar_mandi': int(request.form.get('kamar_mandi', 1)),\n            'carport': int(request.form.get('carport', 0)),\n            'tahun_dibangun': int(request.form.get('tahun_dibangun', 2020)),\n            'lantai': int(request.form.get('lantai', 1)),\n            'jarak_sekolah': float(request.form.get('jarak_sekolah', 1000)),\n            'jarak_rs': float(request.form.get('jarak_rs', 2000)),\n            'jarak_pasar': float(request.form.get('jarak_pasar', 1500)),\n            'jenis_jalan': request.form.get('jenis_jalan'),\n            'kondisi': request.form.get('kondisi'),\n            'sertifikat': request.form.get('sertifikat')\n        }\n        \n        # Get price prediction\n        predicted_price = ml_service.predict_price(property_data)\n        \n        if predicted_price:\n            # Calculate price range (±20% from predicted)\n            variation = predicted_price * 0.2\n            price_range = {\n                'min_price': max(0, predicted_price - variation),\n                'max_price': predicted_price + variation,\n                'predicted_price': predicted_price,\n                'formatted_predicted': f\"Rp {predicted_price:,.0f}\".replace(',', '.'),\n                'formatted_min': f\"Rp {max(0, predicted_price - variation):,.0f}\".replace(',', '.'),\n                'formatted_max': f\"Rp {predicted_price + variation:,.0f}\".replace(',', '.')\n            }\n            \n            # Find similar properties within 30% of predicted price\n            all_properties = PropertyRepository.load_properties()\n            price_tolerance = predicted_price * 0.3  # 30% tolerance\n            min_similar_price = predicted_price - price_tolerance\n            max_similar_price = predicted_price + price_tolerance\n            \n            for prop in all_properties:\n                if prop.get('harga') and prop.get('status') == 'available':\n                    prop_price = float(prop['harga'])\n                    if min_similar_price <= prop_price <= max_similar_price:\n                        similar_properties.append(prop)\n            \n            # Sort by price difference and limit to 6 properties\n            similar_properties.sort(key=lambda p: abs(float(p['harga']) - predicted_price))\n            similar_properties = similar_properties[:6]\n    \n    return render_template('predict.html', price_range=price_range, similar_properties=similar_properties)\n\n","size_bytes":4842},"app/services/__init__.py":{"content":"# Services package","size_bytes":18},"app/services/ai_service.py":{"content":"import json\nimport re\nimport os\nfrom typing import List, Dict, Optional, Tuple\nfrom dotenv import load_dotenv\nfrom app.models import PropertyRepository\nfrom app.utils.search_utils import extract_search_criteria, filter_properties_strict\n\n# Load environment variables\nload_dotenv()\n\n# Import Gemini AI integration\ntry:\n    from google import genai\n    from google.genai import types\n    api_key = os.getenv(\"GEMINI_API_KEY\")\n    if api_key and api_key != \"your_gemini_api_key_here\":\n        client = genai.Client(api_key=api_key)\n        GEMINI_AVAILABLE = True\n    else:\n        raise ValueError(\"GEMINI_API_KEY not found or not configured\")\nexcept Exception as e:\n    print(f\"Gemini AI not available: {e}\")\n    GEMINI_AVAILABLE = False\n    client = None\n    types = None\n\nclass AIPropertySearch:\n    \"\"\"Enhanced AI-powered property search with clean deterministic filtering\"\"\"\n\n    @staticmethod\n    def search_properties(query: str) -> Dict:\n        \"\"\"\n        Search properties using clean NLP extraction and scoring\n        Returns: Dict with properties, explanation, and ai_powered flag\n        \"\"\"\n        if not query.strip():\n            properties = PropertyRepository.load_properties()[:6]\n            return {\n                'properties': properties,\n                'explanation': 'Menampilkan beberapa properti terbaru.',\n                'ai_powered': False\n            }\n\n        # Check for non-property queries\n        if AIPropertySearch._is_non_property_query(query):\n            return {\n                'properties': [],\n                'explanation': 'Silakan berikan kriteria pencarian properti yang lebih spesifik, seperti budget, jumlah kamar, atau lokasi yang diinginkan.',\n                'ai_powered': True\n            }\n\n        # Load all properties\n        all_properties = PropertyRepository.load_properties()\n\n        # Extract search criteria using NLP\n        criteria = extract_search_criteria(query)\n        print(f\"Extracted criteria: {criteria}\")  # Debug\n\n        # Apply filtering and scoring\n        filtered_properties = filter_properties_strict(all_properties, criteria)\n        print(f\"Filtered results: {len(filtered_properties)} properties\")  # Debug\n\n        # If we have results, return them\n        if filtered_properties:\n            result_count = min(len(filtered_properties), 6)\n            explanation = AIPropertySearch._generate_explanation(criteria, len(filtered_properties))\n\n            return {\n                'properties': filtered_properties[:result_count],\n                'explanation': explanation,\n                'ai_powered': True\n            }\n\n        # No results found - return empty with helpful message\n        return {\n            'properties': [],\n            'explanation': 'Tidak ada properti yang sesuai dengan kriteria pencarian Anda. Coba ubah kriteria seperti budget atau lokasi.',\n            'ai_powered': True\n        }\n\n    @staticmethod\n    def _is_non_property_query(query: str) -> bool:\n        \"\"\"Check if query is non-property related\"\"\"\n        non_property_queries = ['hai', 'hello', 'halo', 'hi', 'apa kabar', 'terima kasih', 'thanks', 'bye', 'selamat pagi', 'selamat siang', 'selamat malam']\n        return query.lower().strip() in non_property_queries\n\n    @staticmethod\n    def _generate_explanation(criteria: Dict, total_found: int) -> str:\n        \"\"\"Generate human-friendly explanation based on criteria\"\"\"\n        parts = []\n\n        if 'budget' in criteria:\n            budget = criteria['budget']\n            parts.append(f\"budget sekitar Rp {budget:,.0f}\".replace(',', '.'))\n\n        if 'kamar_tidur' in criteria:\n            parts.append(f\"{criteria['kamar_tidur']} kamar tidur\")\n\n        if 'kamar_mandi' in criteria:\n            parts.append(f\"{criteria['kamar_mandi']} kamar mandi\")\n\n        if 'kelurahan' in criteria:\n            parts.append(f\"di kelurahan {criteria['kelurahan']}\")\n        elif 'kecamatan' in criteria:\n            parts.append(f\"di kecamatan {criteria['kecamatan']}\")\n\n        if parts:\n            criteria_text = \", \".join(parts)\n            return f\"Ditemukan {total_found} properti dengan {criteria_text}. Menampilkan {min(total_found, 6)} properti terbaik.\"\n        else:\n            return f\"Ditemukan {total_found} properti berdasarkan pencarian Anda. Menampilkan {min(total_found, 6)} properti teratas.\"\n\ndef gemini_chat_response(message: str, context: Optional[str] = None) -> str:\n    \"\"\"Generate chatbot response using Gemini AI\"\"\"\n    if not GEMINI_AVAILABLE or not client:\n        return \"Maaf, layanan chatbot AI sedang tidak tersedia. Silakan hubungi admin untuk mengkonfigurasi GEMINI_API_KEY.\"\n\n    try:\n        properties = PropertyRepository.load_properties()\n        property_context = f\"Available properties count: {len(properties)}\"\n        if properties:\n            prices = [float(p.get('harga', 0)) for p in properties if p.get('harga')]\n            if prices:\n                avg_price = sum(prices) / len(prices)\n                property_context += f\", Average price: Rp {avg_price:,.0f}\"\n\n        system_prompt = f\"\"\"You are a helpful real estate assistant for a property recommendation system. \n        Context: {property_context}\n\n        Help users with:\n        - Property searches and recommendations\n        - Price predictions and market analysis\n        - Location and facility information\n        - Answering questions about property features\n\n        Be friendly, informative, and helpful. Respond in Bahasa Indonesia when appropriate.\"\"\"\n\n        response = client.models.generate_content(\n            model=\"gemini-2.5-flash\",\n            contents=[\n                types.Content(role=\"user\", parts=[types.Part(text=f\"{system_prompt}\\n\\nUser question: {message}\")])\n            ]\n        )\n\n        return response.text if response.text else \"Maaf, saya tidak dapat memproses pertanyaan Anda saat ini.\"\n\n    except Exception as e:\n        return \"Maaf, terjadi kesalahan pada sistem search. Silakan coba lagi.\"","size_bytes":5984},"app/services/ml_service.py":{"content":"import pandas as pd\nimport numpy as np\nfrom sklearn.ensemble import RandomForestRegressor\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import mean_absolute_error, r2_score\nimport pickle\nfrom typing import Optional, Dict, Any\nfrom app.models import PropertyRepository, BasePriceRepository, encode_categorical\nfrom app.config import Config\n\nclass MLPredictionService:\n    \"\"\"Machine Learning service for property price prediction\"\"\"\n    \n    def __init__(self):\n        self.model: Optional[RandomForestRegressor] = None\n        self.scaler: Optional[StandardScaler] = None\n        self.feature_columns = Config.FEATURE_COLUMNS\n    \n    def prepare_ml_data(self) -> Optional[pd.DataFrame]:\n        \"\"\"Prepare data for machine learning\"\"\"\n        properties = PropertyRepository.load_properties()\n        if len(properties) < 5:  # Need minimum data for training\n            return None\n        \n        # Prepare dataset\n        data = []\n        for prop in properties:\n            if prop.get('harga') and all(key in prop for key in ['luas_tanah', 'luas_bangunan']):\n                row = [\n                    float(prop['luas_tanah']),\n                    float(prop['luas_bangunan']),\n                    int(prop.get('kamar_tidur', 2)),\n                    int(prop.get('kamar_mandi', 1)),\n                    int(prop.get('carport', 0)),\n                    int(prop.get('tahun_dibangun', 2020)),\n                    int(prop.get('lantai', 1)),\n                    float(prop.get('jarak_sekolah', 1000)),\n                    float(prop.get('jarak_rs', 2000)),\n                    float(prop.get('jarak_pasar', 1500)),\n                    encode_categorical(prop.get('jenis_jalan'), Config.JENIS_JALAN_MAP),\n                    encode_categorical(prop.get('kondisi'), Config.KONDISI_MAP),\n                    encode_categorical(prop.get('sertifikat'), Config.SERTIFIKAT_MAP),\n                    float(prop['harga'])\n                ]\n                data.append(row)\n        \n        if len(data) < 5:\n            return None\n            \n        columns = self.feature_columns + ['harga']\n        df = pd.DataFrame(data, columns=columns)\n        return df\n    \n    def train_model(self) -> bool:\n        \"\"\"Train the machine learning model\"\"\"\n        df = self.prepare_ml_data()\n        if df is None:\n            return False\n        \n        # Prepare features and target\n        X = df[self.feature_columns]\n        y = df['harga']\n        \n        # Scale features\n        self.scaler = StandardScaler()\n        X_scaled = self.scaler.fit_transform(X)\n        \n        # Train model\n        self.model = RandomForestRegressor(n_estimators=100, random_state=42)\n        self.model.fit(X_scaled, y)\n        \n        # Save model\n        try:\n            with open('models/price_model.pkl', 'wb') as f:\n                pickle.dump({'model': self.model, 'scaler': self.scaler}, f)\n            return True\n        except Exception as e:\n            print(f\"Error saving model: {e}\")\n            return False\n    \n    def load_model(self) -> bool:\n        \"\"\"Load the trained ML model\"\"\"\n        try:\n            with open('models/price_model.pkl', 'rb') as f:\n                model_data = pickle.load(f)\n                self.model = model_data['model']\n                self.scaler = model_data['scaler']\n            return True\n        except FileNotFoundError:\n            return self.train_model()\n        except Exception as e:\n            print(f\"Error loading model: {e}\")\n            return False\n    \n    def predict_price(self, property_data: Dict[str, Any]) -> Optional[float]:\n        \"\"\"Predict house price using 100% Machine Learning model\"\"\"\n        # Use pure ML prediction\n        ml_prediction = self._get_ml_prediction(property_data)\n        return ml_prediction\n    \n    def _get_ml_prediction(self, property_data: Dict[str, Any]) -> Optional[float]:\n        \"\"\"Get ML model prediction\"\"\"\n        if self.model is None:\n            if not self.load_model():\n                return None\n        \n        # Prepare input data\n        tahun_dibangun = int(property_data.get('tahun_dibangun', 2020))\n        \n        features = [\n            float(property_data.get('luas_tanah', 100)),\n            float(property_data.get('luas_bangunan', 80)),\n            int(property_data.get('kamar_tidur', 2)),\n            int(property_data.get('kamar_mandi', 1)),\n            int(property_data.get('carport', 0)),\n            tahun_dibangun,\n            int(property_data.get('lantai', 1)),\n            float(property_data.get('jarak_sekolah', 1000)),\n            float(property_data.get('jarak_rs', 2000)),\n            float(property_data.get('jarak_pasar', 1500)),\n            encode_categorical(property_data.get('jenis_jalan'), Config.JENIS_JALAN_MAP),\n            encode_categorical(property_data.get('kondisi'), Config.KONDISI_MAP),\n            encode_categorical(property_data.get('sertifikat'), Config.SERTIFIKAT_MAP)\n        ]\n        \n        print(f\"Debug ML - Year built feature: {tahun_dibangun}\")\n        \n        # Scale and predict\n        if self.scaler is not None and self.model is not None:\n            try:\n                features_scaled = self.scaler.transform([features])\n                prediction = self.model.predict(features_scaled)[0]\n                return max(0, prediction)\n            except Exception as e:\n                print(f\"Error predicting price: {e}\")\n                return None\n        \n        return None\n    \n    def _get_base_price_prediction(self, property_data: Dict[str, Any]) -> Optional[float]:\n        \"\"\"Calculate price using base price methodology\"\"\"\n        try:\n            base_prices = BasePriceRepository.load_base_prices()\n            \n            # Basic calculation\n            luas_tanah = float(property_data.get('luas_tanah', 100))\n            luas_bangunan = float(property_data.get('luas_bangunan', 80))\n            kamar_tidur = int(property_data.get('kamar_tidur', 2))\n            kamar_mandi = int(property_data.get('kamar_mandi', 1))\n            lantai = int(property_data.get('lantai', 1))\n            tahun_dibangun = int(property_data.get('tahun_dibangun', 2020))\n            \n            # Base price calculation\n            land_value = luas_tanah * base_prices['base_price_per_sqm_land']\n            building_value = luas_bangunan * base_prices['base_price_per_sqm_building']\n            room_bonus = kamar_tidur * base_prices['room_multiplier']\n            bathroom_bonus = kamar_mandi * base_prices['bathroom_multiplier']\n            floor_bonus = lantai * base_prices.get('floor_multiplier', 10000000)  # Default 10M per floor\n            \n            # Calculate age factor - newer buildings are more valuable\n            current_year = 2025\n            building_age = current_year - tahun_dibangun\n            \n            # Age multiplier: newer = higher value, older = lower value\n            # Buildings 0-5 years: 100% value\n            # Buildings 6-10 years: 95% value  \n            # Buildings 11-15 years: 90% value\n            # Buildings 16-20 years: 85% value\n            # Buildings >20 years: 80% value\n            if building_age <= 5:\n                age_multiplier = 1.0\n            elif building_age <= 10:\n                age_multiplier = 0.95\n            elif building_age <= 15:\n                age_multiplier = 0.90\n            elif building_age <= 20:\n                age_multiplier = 0.85\n            else:\n                age_multiplier = 0.80\n            \n            print(f\"Debug - Year built: {tahun_dibangun}, Age: {building_age}, Age multiplier: {age_multiplier}\")\n            \n            base_total = (land_value + building_value + room_bonus + bathroom_bonus + floor_bonus) * age_multiplier\n            \n            # Apply multipliers\n            kondisi = property_data.get('kondisi', 'baik')\n            condition_mult = base_prices['condition_multipliers'].get(kondisi, 1.0)\n            \n            jenis_jalan = property_data.get('jenis_jalan', 'jalan_sedang')\n            road_mult = base_prices['road_multipliers'].get(jenis_jalan, 1.0)\n            \n            sertifikat = property_data.get('sertifikat', 'hgb')\n            cert_mult = base_prices['certificate_multipliers'].get(sertifikat, 1.0)\n            \n            final_price = base_total * condition_mult * road_mult * cert_mult\n            \n            return max(0, final_price)\n            \n        except Exception as e:\n            print(f\"Error calculating base price: {e}\")\n            return None\n    \n    def get_price_range(self, property_data: Dict[str, Any]) -> Optional[Dict[str, float]]:\n        \"\"\"Get price range (min, max, predicted)\"\"\"\n        predicted_price = self.predict_price(property_data)\n        if predicted_price is None:\n            return None\n        \n        # Calculate range (±20% from predicted)\n        variation = predicted_price * 0.2\n        return {\n            'min_price': max(0, predicted_price - variation),\n            'max_price': predicted_price + variation,\n            'predicted_price': predicted_price\n        }\n\n# Global ML service instance\nml_service = MLPredictionService()","size_bytes":9201},"app/utils/__init__.py":{"content":"# Utils package","size_bytes":15},"app/utils/phone_utils.py":{"content":"import re\nfrom urllib.parse import quote_plus\n\ndef normalize_indonesian_phone(phone_number):\n    \"\"\"\n    Normalize Indonesian phone numbers for WhatsApp links\n    Converts various formats to proper international format (62XXXXXXXXX)\n    \"\"\"\n    if not phone_number:\n        return None\n    \n    # Remove all non-digit characters\n    clean_number = re.sub(r'\\D', '', phone_number)\n    \n    if not clean_number:\n        return None\n    \n    # Handle different formats\n    if clean_number.startswith('62'):\n        # Already in international format\n        return clean_number\n    elif clean_number.startswith('0'):\n        # Local format (08xxx) -> convert to international (62xxx)\n        return '62' + clean_number[1:]\n    else:\n        # Assume it's missing the country code and leading 0\n        return '62' + clean_number\n    \ndef create_whatsapp_link(phone_number, seller_name, property_title):\n    \"\"\"\n    Create a properly formatted WhatsApp link with normalized phone and encoded message\n    \"\"\"\n    normalized_phone = normalize_indonesian_phone(phone_number)\n    \n    if not normalized_phone:\n        return None\n    \n    # Create message text\n    message = f\"Halo {seller_name or 'Penjual'}, saya tertarik dengan properti {property_title} yang sedang dijual. Bisa kita diskusi lebih lanjut?\"\n    \n    # URL encode the message\n    encoded_message = quote_plus(message)\n    \n    # Create WhatsApp link\n    whatsapp_link = f\"https://wa.me/{normalized_phone}?text={encoded_message}\"\n    \n    return whatsapp_link","size_bytes":1517},"app/utils/search_utils.py":{"content":"import re\nfrom typing import Dict, List, Optional, Any\n\ndef extract_search_criteria(query: str) -> Dict[str, Any]:\n    \"\"\"\n    Extract search criteria from query using enhanced NLP patterns\n    Returns: Dict with extracted criteria\n    \"\"\"\n    query_lower = query.lower().strip()\n    criteria = {}\n\n    # Normalize conversational patterns\n    query_lower = re.sub(r'\\b(ada\\s*ga|ada\\s*tidak|ada\\s*ngga|ada\\s*enggak)\\b', '', query_lower)\n    query_lower = re.sub(r'\\b(kalau|kalo|gimana|bagaimana|berapa)\\b', '', query_lower)\n    query_lower = re.sub(r'\\b(rumah|properti|yang|dengan|punya|memiliki|untuk|saya|mau|ingin|cari|mencari|butuh)\\b', ' ', query_lower)\n    query_lower = query_lower.strip()\n\n    # Extract budget with improved patterns\n    budget_patterns = [\n        (r'(\\d+)\\s*jutaan', 1000000),\n        (r'(\\d+)\\s*juta', 1000000),\n        (r'kisaran\\s*(\\d+)', 1000000),\n        (r'budget\\s*(\\d+)', 1000000),\n        (r'(\\d+)\\s*m\\b', 1000000),\n        (r'harga\\s*(\\d+)', 1000000),\n        (r'(\\d+)\\s*milyar', 1000000000),\n    ]\n\n    for pattern, multiplier in budget_patterns:\n        matches = re.findall(pattern, query_lower)\n        if matches:\n            budget = int(matches[0]) * multiplier\n            criteria['budget'] = budget\n            # Flexible range ±30%\n            criteria['budget_range'] = (budget * 0.7, budget * 1.3)\n            break\n\n    # Extract bedroom count\n    room_patterns = [\n        r'(\\d+)\\s*kamar\\s*tidur',\n        r'(\\d+)\\s*kt\\b',\n        r'kt\\s*(\\d+)',\n        r'(\\d+)\\s*bedroom',\n        r'(\\d+)\\s*kamar(?!\\s*mandi)',\n    ]\n\n    for pattern in room_patterns:\n        matches = re.findall(pattern, query_lower)\n        if matches:\n            criteria['kamar_tidur'] = int(matches[0])\n            break\n\n    # Extract bathroom count\n    bathroom_patterns = [\n        r'(\\d+)\\s*kamar\\s*mandi',\n        r'(\\d+)\\s*km\\b',\n        r'km\\s*(\\d+)',\n        r'(\\d+)\\s*bathroom',\n    ]\n\n    for pattern in bathroom_patterns:\n        matches = re.findall(pattern, query_lower)\n        if matches:\n            criteria['kamar_mandi'] = int(matches[0])\n            break\n\n    # Extract location\n    kelurahan_list = [\n        'majasari', 'sukaraja', 'gunung ibul', 'gunungibul', 'patih galung',\n        'wonosari', 'gunung kemala', 'sukajadi', 'karang bindu', 'tanjung telang',\n        'tanjung raman', 'cambai', 'muara dua', 'anak petai', 'pangkul', \n        'karang jaya', 'gunung ibul barat', 'mangga'\n    ]\n\n    kecamatan_list = [\n        'prabumulih selatan', 'prabumulih timur', 'prabumulih barat', \n        'prabumulih utara', 'cambai', 'rambang kapak tengah'\n    ]\n\n    # Check for kelurahan\n    for kelurahan in kelurahan_list:\n        if kelurahan in query_lower:\n            criteria['kelurahan'] = kelurahan.replace('gunungibul', 'gunung ibul').title()\n            break\n\n    # Check for kecamatan if no kelurahan found\n    if 'kelurahan' not in criteria:\n        for kecamatan in kecamatan_list:\n            if kecamatan in query_lower:\n                criteria['kecamatan'] = kecamatan.title()\n                break\n\n    # Price preferences\n    if any(term in query_lower for term in ['murah', 'termurah', 'paling murah', 'cheap']):\n        criteria['price_preference'] = 'low'\n    elif any(term in query_lower for term in ['mahal', 'termahal', 'mewah', 'luxury']):\n        criteria['price_preference'] = 'high'\n\n    return criteria\n\ndef calculate_property_score(prop: Dict, criteria: Dict[str, Any]) -> float:\n    \"\"\"Calculate relevance score for a property based on criteria\"\"\"\n    score = 0.0\n\n    # Price scoring (40 points max)\n    if 'budget' in criteria:\n        budget = criteria['budget']\n        prop_price = prop.get('harga', 0)\n        if prop_price > 0:\n            price_diff_percent = abs(prop_price - budget) / budget\n            if price_diff_percent <= 0.1:\n                score += 40\n            elif price_diff_percent <= 0.3:\n                score += 30\n            elif price_diff_percent <= 0.5:\n                score += 20\n            elif price_diff_percent <= 0.8:\n                score += 10\n\n    # Bedroom scoring (25 points max)\n    if 'kamar_tidur' in criteria:\n        prop_rooms = prop.get('kamar_tidur', 0)\n        required_rooms = criteria['kamar_tidur']\n        if prop_rooms == required_rooms:\n            score += 25\n        elif abs(prop_rooms - required_rooms) == 1:\n            score += 12\n\n    # Bathroom scoring (15 points max)\n    if 'kamar_mandi' in criteria:\n        prop_bathrooms = prop.get('kamar_mandi', 0)\n        required_bathrooms = criteria['kamar_mandi']\n        if prop_bathrooms == required_bathrooms:\n            score += 15\n        elif abs(prop_bathrooms - required_bathrooms) == 1:\n            score += 7\n\n    # Location scoring (20 points max)\n    if 'kelurahan' in criteria:\n        prop_kelurahan = prop.get('kelurahan', '').lower().strip()\n        criteria_kelurahan = criteria['kelurahan'].lower().strip()\n        if prop_kelurahan == criteria_kelurahan or criteria_kelurahan in prop_kelurahan:\n            score += 20\n\n    if 'kecamatan' in criteria:\n        prop_kecamatan = prop.get('kecamatan', '').lower().strip()\n        criteria_kecamatan = criteria['kecamatan'].lower().strip()\n        if prop_kecamatan == criteria_kecamatan or criteria_kecamatan in prop_kecamatan:\n            score += 20\n\n    return score\n\ndef filter_properties_strict(properties: List[Dict], criteria: Dict[str, Any]) -> List[Dict]:\n    \"\"\"Apply scoring-based filtering for varied and relevant results\"\"\"\n    if not criteria:\n        # No criteria - return all available properties sorted by date\n        return [p for p in properties if p.get('status') == 'available']\n\n    # Calculate scores for all available properties\n    scored_properties = []\n    for prop in properties:\n        if prop.get('status') != 'available':\n            continue\n\n        score = calculate_property_score(prop, criteria)\n\n        # Apply hard filters for budget range\n        passes_filter = True\n        if 'budget_range' in criteria:\n            prop_price = prop.get('harga', 0)\n            if prop_price > 0:\n                min_budget, max_budget = criteria['budget_range']\n                if prop_price < min_budget or prop_price > max_budget:\n                    passes_filter = False\n\n        # Include properties that either pass filters OR have a positive score\n        if passes_filter or score > 0:\n            scored_properties.append({\n                'property': prop,\n                'score': score\n            })\n\n    # Sort by score (highest first)\n    scored_properties.sort(key=lambda x: x['score'], reverse=True)\n\n    # Extract properties\n    filtered = [item['property'] for item in scored_properties]\n\n    # Apply price preference for final sorting\n    if 'price_preference' in criteria and len(filtered) > 0:\n        if criteria['price_preference'] == 'low':\n            # Sort by price ascending\n            filtered.sort(key=lambda p: p.get('harga', float('inf')))\n        elif criteria['price_preference'] == 'high':\n            # Sort by price descending\n            filtered.sort(key=lambda p: p.get('harga', 0), reverse=True)\n\n    return filtered\n\ndef is_property_related_query(query: str) -> bool:\n    \"\"\"Check if query contains property-related keywords (enhanced)\"\"\"\n    property_keywords = [\n        'rumah', 'juta', 'kamar', 'budget', 'luas', 'sekolah', 'hospital', 'pasar', \n        'properti', 'beli', 'cari', 'house', 'bedroom', 'bathroom', 'price', 'search',\n        'carport', 'garasi', 'tanah', 'bangunan', 'sertifikat', 'kelurahan', 'alamat',\n        'kt', 'km', 'wc', 'm2', 'meter', 'dekat', 'deket', 'jarak', 'kondisi',\n        'shm', 'hgb', 'tahun', 'dibangun', 'renovasi', 'mandi', 'tidur', 'ada',\n        'di', 'daerah', 'wilayah', 'area', 'lokasi', 'kecamatan',\n        'mencari', 'sedang', 'butuh', 'ingin', 'perlu', 'mau',\n        # Kelurahan keywords\n        'majasari', 'sukaraja', 'gunung ibul', 'patih galung', 'wonosari',\n        'gunung kemala', 'sukajadi', 'karang bindu', 'tanjung telang', 'tanjung raman',\n        'cambai', 'muara dua', 'anak petai', 'pangkul', 'karang jaya', 'gunung ibul barat', 'mangga',\n        # Kecamatan keywords\n        'prabumulih selatan', 'prabumulih timur', 'prabumulih barat', \n        'prabumulih utara', 'rambang kapak tengah'\n    ]\n    query_lower = query.lower()\n    return any(keyword in query_lower for keyword in property_keywords)","size_bytes":8401},"replit.md":{"content":"# Prediksi Harga Rumah - Real Estate Price Prediction App\n\n## Overview\nThis is a Flask-based real estate property management and price prediction application for properties in Prabumulih, Indonesia. It uses Machine Learning (Random Forest) and AI (Google Gemini) to help users find properties and predict property prices.\n\n## Project Architecture\n\n### Technology Stack\n- **Backend Framework**: Flask 3.1.2\n- **Package Manager**: uv (Python package manager)\n- **Python Version**: 3.11\n- **ML Framework**: scikit-learn 1.7.2\n- **AI Service**: Google Gemini AI\n- **Production Server**: Gunicorn\n\n### Project Structure\n```\n.\n├── app/\n│   ├── blueprints/          # Flask blueprints (routes)\n│   │   ├── main.py         # Main user-facing routes\n│   │   ├── admin.py        # Admin panel routes\n│   │   └── api.py          # API endpoints\n│   ├── services/           # Business logic\n│   │   ├── ai_service.py   # Gemini AI integration\n│   │   └── ml_service.py   # ML price prediction\n│   ├── utils/              # Utility functions\n│   ├── config.py           # Application configuration\n│   └── models.py           # Data models (JSON-based)\n├── data/\n│   ├── properties.json     # Property database\n│   └── base_prices.json    # Base price settings\n├── models/\n│   └── price_model.pkl     # Trained ML model\n├── static/                 # Static files (images, CSS, JS)\n├── templates/              # HTML templates\n└── main.py                 # Application entry point\n```\n\n## Features\n\n### User Features\n1. **Property Search**: Natural language property search using AI\n2. **Property Listings**: Browse and filter properties by budget and location\n3. **Price Prediction**: ML-based property price prediction based on:\n   - Land area (luas tanah)\n   - Building area (luas bangunan)\n   - Number of bedrooms/bathrooms\n   - Building condition\n   - Certificate type\n   - Location factors\n\n### Admin Features\n1. **Property Management**: Add, edit, delete properties\n2. **Base Price Settings**: Configure pricing parameters\n3. **Prediction Dashboard**: View price predictions\n\n## Data Storage\nThe application uses JSON file-based storage:\n- **Properties**: Stored in `data/properties.json`\n- **Base Prices**: Stored in `data/base_prices.json`\n\n## Configuration\n\n### Environment Variables\nThe following environment variables are configured in `.env`:\n- `GEMINI_API_KEY`: API key for Google Gemini AI\n- `GOOGLE_MAPS_API_KEY`: API key for Google Maps (optional)\n- `SESSION_SECRET`: Flask session secret key\n\n### ML Model\n- **Type**: Random Forest Regressor\n- **Training Version**: scikit-learn 1.5.2\n- **Current Version**: scikit-learn 1.7.2 (backward compatible with warnings)\n- **Location**: `models/price_model.pkl`\n\n## Development\n\n### Running Locally\nThe application runs on port 5000:\n```bash\nuv run python main.py\n```\n\n### Deployment\nConfigured for Replit Autoscale deployment using Gunicorn:\n```bash\ngunicorn --bind=0.0.0.0:5000 --reuse-port main:app\n```\n\n## Recent Changes (October 2025)\n- Migrated to Replit environment\n- Configured uv package manager\n- Set up development workflow on port 5000\n- Configured production deployment with Gunicorn\n- Added .gitignore for Python project\n- **Changed prediction to 100% Machine Learning**: Removed base price calculation hybrid model, now uses pure ML predictions\n\n## Known Issues\n- ML model shows version warnings (trained with scikit-learn 1.5.2, running on 1.7.2)\n  - This is non-critical and doesn't affect functionality\n  - Consider retraining model with current version if needed\n\n## Notes\n- The application is designed for properties in Prabumulih, South Sumatra, Indonesia\n- Uses Indonesian language (Bahasa Indonesia) for the interface\n- Implements ProxyFix middleware for proper handling in Replit environment\n","size_bytes":3912}},"version":1}