{"file_contents":{"main.py":{"content":"\"\"\"\nMain application entry point using Flask app factory pattern\n\"\"\"\nfrom app import create_app\nfrom app.services.ml_service import ml_service\n\n# Create Flask application\napp = create_app()\n\nif __name__ == '__main__':\n    # Initialize ML model on startup\n    ml_service.load_model()\n    app.run(host='0.0.0.0', port=5000, debug=False)","size_bytes":334},"pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"email-validator>=2.3.0\",\n    \"flask-sqlalchemy>=3.1.1\",\n    \"flask>=3.1.2\",\n    \"google-genai>=1.38.0\",\n    \"gunicorn>=23.0.0\",\n    \"numpy>=2.3.3\",\n    \"pandas>=2.3.2\",\n    \"pillow>=11.3.0\",\n    \"pydantic>=2.11.9\",\n    \"python-dotenv>=1.1.1\",\n    \"requests>=2.32.5\",\n    \"scikit-learn>=1.7.2\",\n    \"sift-stack-py>=0.9.1\",\n    \"werkzeug>=3.1.3\",\n    \"psycopg2-binary>=2.9.10\",\n]\n","size_bytes":525},"app/__init__.py":{"content":"import os\nfrom flask import Flask\nfrom werkzeug.middleware.proxy_fix import ProxyFix\nfrom dotenv import load_dotenv\n\ndef create_app():\n    \"\"\"Flask application factory\"\"\"\n    load_dotenv()\n    \n    # Configure Flask to use templates and static files from root directory\n    app = Flask(__name__, \n                template_folder='../templates',\n                static_folder='../static')\n    from app.config import Config\n    app.secret_key = Config.SECRET_KEY\n    \n    # Configure ProxyFix for Replit environment\n    app.wsgi_app = ProxyFix(app.wsgi_app, x_proto=1, x_host=1)\n    \n    app.config['UPLOAD_FOLDER'] = 'static/images'\n    app.config['MAX_CONTENT_LENGTH'] = 16 * 1024 * 1024  # 16MB max file size\n    \n    # Ensure required directories exist\n    os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)\n    os.makedirs('data', exist_ok=True)\n    os.makedirs('models', exist_ok=True)\n    \n    # Register blueprints\n    from app.blueprints.main import main_bp\n    from app.blueprints.admin import admin_bp\n    from app.blueprints.api import api_bp\n    \n    app.register_blueprint(main_bp)\n    app.register_blueprint(admin_bp, url_prefix='/admin')\n    app.register_blueprint(api_bp, url_prefix='/api')\n    \n    return app","size_bytes":1230},"app/config.py":{"content":"import os\nfrom dotenv import load_dotenv\n\n# Load environment variables\nload_dotenv()\n\nclass Config:\n    \"\"\"Application configuration\"\"\"\n    SECRET_KEY = os.getenv('SESSION_SECRET')\n    if not SECRET_KEY or SECRET_KEY == 'your_session_secret_here_change-this-to-random-string':\n        SECRET_KEY = 'dev-secret-key-change-in-production'  # Fallback for development\n\n    UPLOAD_FOLDER = 'static/images'\n    MAX_CONTENT_LENGTH = 16 * 1024 * 1024  # 16MB max file size\n\n    # ML Model configuration\n    FEATURE_COLUMNS = [\n        'luas_tanah', 'luas_bangunan', 'kamar_tidur', 'kamar_mandi', \n        'carport', 'tahun_dibangun', 'lantai', 'jarak_sekolah', 'jarak_rs', \n        'jarak_pasar', 'jenis_jalan_encoded', 'kondisi_encoded', 'sertifikat_encoded'\n    ]\n\n    # Gemini AI configuration\n    GEMINI_API_KEY = os.getenv('GEMINI_API_KEY')\n\n    # Google Maps configuration\n    GOOGLE_MAPS_API_KEY = os.getenv('GOOGLE_MAPS_API_KEY')\n\n    # Encoding mappings for categorical variables\n    JENIS_JALAN_MAP = {'gang_kecil': 1, 'jalan_sedang': 2, 'jalan_besar': 3}\n    KONDISI_MAP = {'butuh_renovasi': 1, 'renovasi_ringan': 2, 'baik': 3, 'baru': 4}\n    SERTIFIKAT_MAP = {'girik': 1, 'hgb': 2, 'shm': 3}\n\n    # Prabumulih-specific area mappings\n    AREA_MAP = {\n        'pusat_kota': 4,        # Pusat Kota Prabumulih\n        'karang_raja': 3,       # Karang Raja\n        'gunung_ibul': 3,       # Gunung Ibul  \n        'rambutan': 2,          # Rambutan\n        'tanjung_api': 2,       # Tanjung Api\n        'cambai': 1             # Cambai\n    }\n\n    # Regional price factors for Prabumulih\n    PRABUMULIH_PRICE_FACTORS = {\n        'coal_proximity_bonus': 0.1,    # Bonus jika dekat area pertambangan\n        'city_center_multiplier': 1.3,   # Multiplier untuk pusat kota\n        'education_facility_bonus': 0.05  # Bonus fasilitas pendidikan\n    }","size_bytes":1842},"app/models.py":{"content":"import json\nimport os\nfrom typing import List, Dict, Optional\nfrom app.config import Config\n\nclass PropertyRepository:\n    \"\"\"Handle property data operations\"\"\"\n    \n    @staticmethod\n    def load_properties() -> List[Dict]:\n        \"\"\"Load properties from JSON file\"\"\"\n        try:\n            with open('data/properties.json', 'r') as f:\n                return json.load(f)\n        except FileNotFoundError:\n            return []\n    \n    @staticmethod\n    def save_properties(properties: List[Dict]) -> None:\n        \"\"\"Save properties to JSON file\"\"\"\n        with open('data/properties.json', 'w') as f:\n            json.dump(properties, f, indent=2)\n    \n    @staticmethod\n    def get_property_by_id(property_id: str) -> Optional[Dict]:\n        \"\"\"Get property by ID\"\"\"\n        properties = PropertyRepository.load_properties()\n        return next((p for p in properties if p['id'] == property_id), None)\n    \n    @staticmethod\n    def add_property(property_data: Dict) -> None:\n        \"\"\"Add new property\"\"\"\n        properties = PropertyRepository.load_properties()\n        properties.append(property_data)\n        PropertyRepository.save_properties(properties)\n    \n    @staticmethod\n    def update_property(property_id: str, updated_data: Dict) -> bool:\n        \"\"\"Update existing property\"\"\"\n        properties = PropertyRepository.load_properties()\n        for i, property_data in enumerate(properties):\n            if property_data['id'] == property_id:\n                # Keep the original ID and created_at\n                updated_data['id'] = property_id\n                if 'created_at' not in updated_data and 'created_at' in property_data:\n                    updated_data['created_at'] = property_data['created_at']\n                properties[i] = updated_data\n                PropertyRepository.save_properties(properties)\n                return True\n        return False\n\n    @staticmethod\n    def delete_property(property_id: str) -> bool:\n        \"\"\"Delete property by ID\"\"\"\n        properties = PropertyRepository.load_properties()\n        original_count = len(properties)\n        properties = [p for p in properties if p['id'] != property_id]\n        \n        if len(properties) < original_count:\n            PropertyRepository.save_properties(properties)\n            return True\n        return False\n\ndef encode_categorical(value: str, mapping: Dict[str, int]) -> int:\n    \"\"\"Encode categorical values using provided mapping\"\"\"\n    return mapping.get(value, 0)\n\nclass BasePriceRepository:\n    \"\"\"Handle base price settings for predictions\"\"\"\n    \n    @staticmethod\n    def load_base_prices() -> Dict:\n        \"\"\"Load base price settings from JSON file\"\"\"\n        try:\n            with open('data/base_prices.json', 'r') as f:\n                return json.load(f)\n        except FileNotFoundError:\n            # Default base prices\n            default_prices = {\n                'base_price_per_sqm_land': 500000,  # Rp per m2 tanah\n                'base_price_per_sqm_building': 2000000,  # Rp per m2 bangunan\n                'room_multiplier': 50000000,  # Bonus per kamar\n                'bathroom_multiplier': 25000000,  # Bonus per kamar mandi\n                'floor_multiplier': 10000000,  # Bonus per lantai\n                'carport_multiplier': 15000000,  # Bonus per carport\n                'year_bonus_per_year': 2000000,  # Bonus per tahun setelah 2000\n                'condition_multipliers': {\n                    'baru': 1.3,\n                    'baik': 1.0,\n                    'renovasi_ringan': 0.8,\n                    'butuh_renovasi': 0.6\n                },\n                'road_multipliers': {\n                    'jalan_besar': 1.2,\n                    'jalan_sedang': 1.0,\n                    'gang_kecil': 0.8\n                },\n                'certificate_multipliers': {\n                    'shm': 1.1,\n                    'hgb': 1.0,\n                    'girik': 0.9\n                }\n            }\n            BasePriceRepository.save_base_prices(default_prices)\n            return default_prices\n    \n    @staticmethod\n    def save_base_prices(base_prices: Dict) -> bool:\n        \"\"\"Save base price settings to JSON file\"\"\"\n        try:\n            # Ensure the data directory exists\n            os.makedirs('data', exist_ok=True)\n            \n            with open('data/base_prices.json', 'w') as f:\n                json.dump(base_prices, f, indent=2)\n            return True\n        except Exception as e:\n            print(f\"Error saving base prices: {e}\")\n            return False\n    \n    @staticmethod\n    def update_base_prices(updated_data: Dict) -> bool:\n        \"\"\"Update base price settings\"\"\"\n        try:\n            current_prices = BasePriceRepository.load_base_prices()\n            current_prices.update(updated_data)\n            BasePriceRepository.save_base_prices(current_prices)\n            return True\n        except Exception as e:\n            print(f\"Error updating base prices: {e}\")\n            return False","size_bytes":4986},"app/blueprints/__init__.py":{"content":"# Blueprints package","size_bytes":20},"app/blueprints/admin.py":{"content":"import uuid\nimport os\nfrom datetime import datetime\nfrom flask import Blueprint, render_template, request, redirect, url_for, flash, current_app\nfrom werkzeug.utils import secure_filename\nfrom app.models import PropertyRepository, BasePriceRepository # Assuming BasePriceRepository exists\nfrom app.services.ml_service import ml_service\nimport re\n\ndef _parse_price(price_str):\n    \"\"\"Parse price string with robust regex to remove all non-digits\"\"\"\n    if not price_str:\n        return None\n    try:\n        # Remove all non-digit characters using regex\n        cleaned = re.sub(r\"[^0-9]\", \"\", str(price_str))\n        return int(cleaned) if cleaned else None\n    except (ValueError, AttributeError):\n        return None\n\nadmin_bp = Blueprint('admin', __name__)\n\n@admin_bp.route('/')\ndef admin_panel():\n    \"\"\"Admin panel dashboard\"\"\"\n    properties = PropertyRepository.load_properties()\n    return render_template('admin/dashboard.html', properties=properties)\n\n@admin_bp.route('/properties')\ndef properties():\n    \"\"\"Properties management page\"\"\"\n    properties = PropertyRepository.load_properties()\n    return render_template('admin/properties.html', properties=properties)\n\n@admin_bp.route('/add_property', methods=['POST'])\ndef add_property():\n    \"\"\"Add new property\"\"\"\n    try:\n        # Handle multiple file uploads\n        image_filenames = []\n        if 'images' in request.files:\n            files = request.files.getlist('images')\n            for file in files:\n                if file and file.filename:\n                    filename = secure_filename(file.filename)\n                    image_filename = f\"{uuid.uuid4()}_{filename}\"\n                    file.save(os.path.join(current_app.config['UPLOAD_FOLDER'], image_filename))\n                    image_filenames.append(image_filename)\n        \n        # Backward compatibility: check for single image upload\n        if 'image' in request.files and not image_filenames:\n            file = request.files['image']\n            if file and file.filename:\n                filename = secure_filename(file.filename)\n                image_filename = f\"{uuid.uuid4()}_{filename}\"\n                file.save(os.path.join(current_app.config['UPLOAD_FOLDER'], image_filename))\n                image_filenames.append(image_filename)\n\n        # Create property data\n        property_data = {\n            'id': str(uuid.uuid4()),\n            'judul_properti': request.form.get('judul_properti'),\n            'kelurahan': request.form.get('kelurahan'),\n            'kecamatan': request.form.get('kecamatan'),\n            'alamat': request.form.get('alamat'),\n            'deskripsi': request.form.get('deskripsi', ''),\n            'luas_tanah': int(request.form.get('luas_tanah') or 0),\n            'luas_bangunan': int(request.form.get('luas_bangunan') or 0),\n            'kamar_tidur': int(request.form.get('kamar_tidur') or 2),\n            'kamar_mandi': int(request.form.get('kamar_mandi') or 1),\n            'carport': int(request.form.get('carport', 0) or 0),\n            'tahun_dibangun': int(request.form.get('tahun_dibangun') or 2020),\n            'lantai': int(request.form.get('lantai', 1) or 1),\n            'kota': request.form.get('kota'),\n            'harga': _parse_price(request.form.get('harga')),\n            'latitude': float(request.form.get('latitude') or 0) if request.form.get('latitude') else None,\n            'longitude': float(request.form.get('longitude') or 0) if request.form.get('longitude') else None,\n            'jarak_sekolah': float(request.form.get('jarak_sekolah', 1000) or 1000),\n            'jarak_rs': float(request.form.get('jarak_rs', 2000) or 2000),\n            'jarak_pasar': float(request.form.get('jarak_pasar', 1500) or 1500),\n            'jenis_jalan': request.form.get('jenis_jalan'),\n            'kondisi': request.form.get('kondisi'),\n            'sertifikat': request.form.get('sertifikat'),\n            'nama_penjual': request.form.get('nama_penjual', ''),\n            'nomor_penjual': request.form.get('nomor_penjual', ''),\n            'images': image_filenames,\n            'image': image_filenames[0] if image_filenames else None,  # Backward compatibility\n            'created_at': datetime.now().isoformat(),\n            'status': 'available'\n        }\n\n        # Save property\n        PropertyRepository.add_property(property_data)\n\n        # Retrain ML model with new data\n        ml_service.train_model()\n\n        flash('Property added successfully!')\n\n    except Exception as e:\n        flash(f'Error adding property: {str(e)}')\n\n    return redirect(url_for('admin.admin_panel'))\n\n@admin_bp.route('/edit_property/<property_id>')\ndef edit_property(property_id):\n    \"\"\"Show edit property form\"\"\"\n    property_data = PropertyRepository.get_property_by_id(property_id)\n    if not property_data:\n        flash('Property not found')\n        return redirect(url_for('admin.admin_panel'))\n\n    return render_template('admin/edit_property.html', property=property_data)\n\n@admin_bp.route('/update_property/<property_id>', methods=['POST'])\ndef update_property(property_id):\n    \"\"\"Update existing property\"\"\"\n    try:\n        property_data = PropertyRepository.get_property_by_id(property_id)\n        if not property_data:\n            flash('Property not found')\n            return redirect(url_for('admin.admin_panel'))\n\n        # Handle multiple file uploads\n        existing_images = property_data.get('images', [])\n        if not existing_images and property_data.get('image'):\n            # Convert old single image to array format\n            existing_images = [property_data.get('image')]\n        \n        image_filenames = existing_images.copy()  # Keep existing images by default\n        \n        if 'images' in request.files:\n            files = request.files.getlist('images')\n            new_images = []\n            for file in files:\n                if file and file.filename:\n                    filename = secure_filename(file.filename)\n                    image_filename = f\"{uuid.uuid4()}_{filename}\"\n                    file.save(os.path.join(current_app.config['UPLOAD_FOLDER'], image_filename))\n                    new_images.append(image_filename)\n            \n            # If new images uploaded, replace all images\n            if new_images:\n                image_filenames = new_images\n        \n        # Backward compatibility: check for single image upload\n        elif 'image' in request.files:\n            file = request.files['image']\n            if file and file.filename:\n                filename = secure_filename(file.filename)\n                image_filename = f\"{uuid.uuid4()}_{filename}\"\n                file.save(os.path.join(current_app.config['UPLOAD_FOLDER'], image_filename))\n                image_filenames = [image_filename]\n\n        # Create updated property data\n        updated_data = {\n            'judul_properti': request.form.get('judul_properti'),\n            'kelurahan': request.form.get('kelurahan'),\n            'kecamatan': request.form.get('kecamatan'),\n            'alamat': request.form.get('alamat'),\n            'deskripsi': request.form.get('deskripsi', ''),\n            'luas_tanah': int(request.form.get('luas_tanah') or 0),\n            'luas_bangunan': int(request.form.get('luas_bangunan') or 0),\n            'kamar_tidur': int(request.form.get('kamar_tidur') or 2),\n            'kamar_mandi': int(request.form.get('kamar_mandi') or 1),\n            'carport': int(request.form.get('carport', 0) or 0),\n            'tahun_dibangun': int(request.form.get('tahun_dibangun') or 2020),\n            'lantai': int(request.form.get('lantai', 1) or 1),\n            'kota': request.form.get('kota'),\n            'harga': _parse_price(request.form.get('harga')),\n            'latitude': float(request.form.get('latitude') or 0) if request.form.get('latitude') else None,\n            'longitude': float(request.form.get('longitude') or 0) if request.form.get('longitude') else None,\n            'jarak_sekolah': float(request.form.get('jarak_sekolah', 1000) or 1000),\n            'jarak_rs': float(request.form.get('jarak_rs', 2000) or 2000),\n            'jarak_pasar': float(request.form.get('jarak_pasar', 1500) or 1500),\n            'jenis_jalan': request.form.get('jenis_jalan'),\n            'kondisi': request.form.get('kondisi'),\n            'sertifikat': request.form.get('sertifikat'),\n            'nama_penjual': request.form.get('nama_penjual', ''),\n            'nomor_penjual': request.form.get('nomor_penjual', ''),\n            'images': image_filenames,\n            'image': image_filenames[0] if image_filenames else None,  # Backward compatibility\n            'status': request.form.get('status', 'available')\n        }\n\n        # Update property\n        if PropertyRepository.update_property(property_id, updated_data):\n            # Retrain ML model with updated data\n            ml_service.train_model()\n            flash('Property updated successfully!')\n        else:\n            flash('Failed to update property')\n\n    except Exception as e:\n        flash(f'Error updating property: {str(e)}')\n\n    return redirect(url_for('main.property_detail', property_id=property_id))\n\n@admin_bp.route('/delete_property/<property_id>')\ndef delete_property(property_id):\n    \"\"\"Delete property\"\"\"\n    if PropertyRepository.delete_property(property_id):\n        # Retrain model\n        ml_service.train_model()\n        flash('Property deleted successfully!')\n    else:\n        flash('Property not found')\n\n    return redirect(url_for('admin.admin_panel'))\n\n# Add routes for base price management\n@admin_bp.route('/get_base_prices')\ndef get_base_prices():\n    \"\"\"Get current base price settings\"\"\"\n    try:\n        base_prices = BasePriceRepository.load_base_prices()\n        return {'success': True, 'data': base_prices}\n    except Exception as e:\n        return {'success': False, 'error': str(e)}\n\n@admin_bp.route('/update_base_prices', methods=['POST'])\ndef update_base_prices():\n    \"\"\"Update base price settings\"\"\"\n    try:\n        data = request.get_json()\n\n        # Format the data properly\n        updated_data = {\n            'base_price_per_sqm_land': float(data.get('base_price_per_sqm_land', 500000)),\n            'base_price_per_sqm_building': float(data.get('base_price_per_sqm_building', 2000000)),\n            'room_multiplier': float(data.get('room_multiplier', 50000000)),\n            'bathroom_multiplier': float(data.get('bathroom_multiplier', 25000000)),\n            'floor_multiplier': float(data.get('floor_multiplier', 10000000)),\n            'carport_multiplier': float(data.get('carport_multiplier', 15000000)),\n            'year_bonus_per_year': float(data.get('year_bonus_per_year', 2000000)),\n            'condition_multipliers': {\n                'baru': float(data.get('condition_baru', 1.3)),\n                'baik': float(data.get('condition_baik', 1.0)),\n                'renovasi_ringan': float(data.get('condition_renovasi_ringan', 0.8)),\n                'butuh_renovasi': float(data.get('condition_butuh_renovasi', 0.6))\n            },\n            'road_multipliers': {\n                'jalan_besar': float(data.get('road_jalan_besar', 1.2)),\n                'jalan_sedang': float(data.get('road_jalan_sedang', 1.0)),\n                'gang_kecil': float(data.get('road_gang_kecil', 0.8))\n            },\n            'certificate_multipliers': {\n                'shm': float(data.get('cert_shm', 1.1)),\n                'hgb': float(data.get('cert_hgb', 1.0)),\n                'girik': float(data.get('cert_girik', 0.9))\n            }\n        }\n\n        if BasePriceRepository.save_base_prices(updated_data):\n            # Retrain ML model with new base prices\n            ml_service.train_model()\n            return {'success': True, 'message': 'Base prices updated successfully!'}\n        else:\n            return {'success': False, 'error': 'Failed to update base prices'}\n\n    except Exception as e:\n        return {'success': False, 'error': str(e)}\n\n@admin_bp.route('/predictions')\ndef predictions():\n    \"\"\"Admin predictions page with base price settings\"\"\"\n    try:\n        base_prices = BasePriceRepository.load_base_prices()\n    except:\n        base_prices = {}\n    return render_template('admin/predictions.html', base_prices=base_prices)\n\n@admin_bp.route('/settings')\ndef settings():\n    \"\"\"Admin settings page\"\"\"\n    return render_template('admin/settings.html')","size_bytes":12374},"app/blueprints/api.py":{"content":"from flask import Blueprint, jsonify, request\nfrom app.models import PropertyRepository\nfrom app.services.ai_service import AIPropertySearch\nfrom app.services.ml_service import ml_service\n\napi_bp = Blueprint('api', __name__)\n\n@api_bp.route('/properties')\ndef get_properties():\n    \"\"\"API endpoint for properties\"\"\"\n    properties = PropertyRepository.load_properties()\n    return jsonify(properties)\n\n@api_bp.route('/search_properties', methods=['POST'])\ndef search_properties():\n    \"\"\"Enhanced AI-powered property search with deterministic filtering\"\"\"\n    try:\n        data = request.get_json()\n        query = data.get('query', '').strip()\n        \n        if not query:\n            return jsonify({\n                'properties': PropertyRepository.load_properties()[:6],\n                'explanation': 'Menampilkan beberapa properti terbaru.',\n                'ai_powered': False\n            })\n        \n        # Use the new AI search service\n        result = AIPropertySearch.search_properties(query)\n        return jsonify(result)\n        \n    except Exception as e:\n        # Fallback to basic properties on error\n        return jsonify({\n            'properties': PropertyRepository.load_properties()[:5],\n            'explanation': 'Terjadi kesalahan dalam pencarian. Menampilkan properti terbaru.',\n            'ai_powered': False,\n            'error': str(e)\n        })\n\n@api_bp.route('/predict', methods=['POST'])\ndef predict_price():\n    \"\"\"API endpoint for price prediction with similar properties\"\"\"\n    try:\n        data = request.get_json()\n        \n        # Log input data for debugging\n        print(f\"Prediction input received: {data}\")\n        print(f\"Input keys: {list(data.keys()) if data else 'No data'}\")\n        print(f\"Input values: {list(data.values()) if data else 'No values'}\")\n        \n        # Get price prediction\n        predicted_price = ml_service.predict_price(data)\n        \n        if predicted_price:\n            # Calculate price range (±20% from predicted)\n            variation = predicted_price * 0.2\n            price_range = {\n                'min_price': max(0, predicted_price - variation),\n                'max_price': predicted_price + variation,\n                'predicted_price': predicted_price,\n                'formatted': f\"Rp {predicted_price:,.0f}\".replace(',', '.')\n            }\n            \n            # Find similar properties within 30% of predicted price\n            all_properties = PropertyRepository.load_properties()\n            similar_properties = []\n            price_tolerance = predicted_price * 0.3  # 30% tolerance\n            min_similar_price = predicted_price - price_tolerance\n            max_similar_price = predicted_price + price_tolerance\n            \n            for prop in all_properties:\n                if prop.get('harga') and prop.get('status') == 'available':\n                    prop_price = float(prop['harga'])\n                    if min_similar_price <= prop_price <= max_similar_price:\n                        similar_properties.append(prop)\n            \n            # Sort by price difference and limit to 6 properties\n            similar_properties.sort(key=lambda p: abs(float(p['harga']) - predicted_price))\n            similar_properties = similar_properties[:6]\n            \n            response_data = {\n                'success': True,\n                'prediction': price_range,\n                'similar_properties': similar_properties,\n                'formatted': price_range['formatted'],\n                'timestamp': request.args.get('t', '')  # Include timestamp for debugging\n            }\n            \n            print(f\"Prediction result: {predicted_price:,.0f}\")  # Debug log\n            \n            # Create response with no-cache headers\n            response = jsonify(response_data)\n            response.headers['Cache-Control'] = 'no-cache, no-store, must-revalidate'\n            response.headers['Pragma'] = 'no-cache'\n            response.headers['Expires'] = '0'\n            \n            return response\n        else:\n            return jsonify({'success': False, 'error': 'Unable to predict price'})\n    \n    except Exception as e:\n        print(f\"Prediction error: {str(e)}\")  # Debug log\n        return jsonify({'success': False, 'error': str(e)})\ndef predict_price():\n    \"\"\"API endpoint for price prediction\"\"\"\n    try:\n        data = request.get_json()\n        prediction = ml_service.predict_price(data)\n        \n        if prediction:\n            return jsonify({\n                'prediction': prediction, \n                'formatted': f\"Rp {prediction:,.0f}\"\n            })\n        else:\n            return jsonify({\n                'error': 'Cannot predict price with current data. Please check if all required fields are provided.'\n            }), 400\n    except Exception as e:\n        return jsonify({\n            'error': f'Prediction failed: {str(e)}'\n        }), 500","size_bytes":4911},"app/blueprints/main.py":{"content":"from flask import Blueprint, render_template, request, redirect, url_for, flash\nfrom app.models import PropertyRepository\nfrom app.services.ai_service import gemini_chat_response\nfrom app.services.ml_service import ml_service\n\nmain_bp = Blueprint('main', __name__)\n\n@main_bp.route('/')\ndef index():\n    \"\"\"Homepage with search functionality\"\"\"\n    properties = PropertyRepository.load_properties()\n    featured_properties = properties[:6]  # Show first 6 as featured\n    return render_template('index.html', properties=featured_properties)\n\n@main_bp.route('/properties')\ndef properties():\n    \"\"\"Property listings page\"\"\"\n    properties = PropertyRepository.load_properties()\n    \n    # Apply filters\n    budget_min = request.args.get('budget_min', type=int)\n    budget_max = request.args.get('budget_max', type=int)\n    kecamatan = request.args.get('kecamatan', type=str)\n    \n    filtered_properties = properties\n    if budget_min:\n        filtered_properties = [p for p in filtered_properties if p.get('harga', 0) >= budget_min]\n    if budget_max:\n        filtered_properties = [p for p in filtered_properties if p.get('harga', 0) <= budget_max]\n    if kecamatan:\n        filtered_properties = [p for p in filtered_properties if p.get('kecamatan', '').strip().lower() == kecamatan.strip().lower()]\n    \n    return render_template('properties.html', properties=filtered_properties)\n\n@main_bp.route('/property/<property_id>')\ndef property_detail(property_id):\n    \"\"\"Property detail page\"\"\"\n    property_data = PropertyRepository.get_property_by_id(property_id)\n    \n    if not property_data:\n        flash('Property not found')\n        return redirect(url_for('main.properties'))\n    \n    # Get similar properties\n    all_properties = PropertyRepository.load_properties()\n    similar_properties = [p for p in all_properties if p['id'] != property_id][:3]\n    \n    return render_template('property_detail.html', property=property_data, similar_properties=similar_properties)\n\n@main_bp.route('/predict', methods=['GET', 'POST'])\ndef predict():\n    \"\"\"Property price prediction page\"\"\"\n    price_range = None\n    similar_properties = []\n    \n    if request.method == 'POST':\n        # Get form data\n        property_data = {\n            'luas_tanah': float(request.form.get('luas_tanah', 0)),\n            'luas_bangunan': float(request.form.get('luas_bangunan', 0)),\n            'kamar_tidur': int(request.form.get('kamar_tidur', 2)),\n            'kamar_mandi': int(request.form.get('kamar_mandi', 1)),\n            'carport': int(request.form.get('carport', 0)),\n            'tahun_dibangun': int(request.form.get('tahun_dibangun', 2020)),\n            'lantai': int(request.form.get('lantai', 1)),\n            'jarak_sekolah': float(request.form.get('jarak_sekolah', 1000)),\n            'jarak_rs': float(request.form.get('jarak_rs', 2000)),\n            'jarak_pasar': float(request.form.get('jarak_pasar', 1500)),\n            'jenis_jalan': request.form.get('jenis_jalan'),\n            'kondisi': request.form.get('kondisi'),\n            'sertifikat': request.form.get('sertifikat')\n        }\n        \n        # Get price prediction\n        predicted_price = ml_service.predict_price(property_data)\n        \n        if predicted_price:\n            # Calculate price range (±20% from predicted)\n            variation = predicted_price * 0.2\n            price_range = {\n                'min_price': max(0, predicted_price - variation),\n                'max_price': predicted_price + variation,\n                'predicted_price': predicted_price,\n                'formatted_predicted': f\"Rp {predicted_price:,.0f}\".replace(',', '.'),\n                'formatted_min': f\"Rp {max(0, predicted_price - variation):,.0f}\".replace(',', '.'),\n                'formatted_max': f\"Rp {predicted_price + variation:,.0f}\".replace(',', '.')\n            }\n            \n            # Find similar properties within 30% of predicted price\n            all_properties = PropertyRepository.load_properties()\n            price_tolerance = predicted_price * 0.3  # 30% tolerance\n            min_similar_price = predicted_price - price_tolerance\n            max_similar_price = predicted_price + price_tolerance\n            \n            for prop in all_properties:\n                if prop.get('harga') and prop.get('status') == 'available':\n                    prop_price = float(prop['harga'])\n                    if min_similar_price <= prop_price <= max_similar_price:\n                        similar_properties.append(prop)\n            \n            # Sort by price difference and limit to 6 properties\n            similar_properties.sort(key=lambda p: abs(float(p['harga']) - predicted_price))\n            similar_properties = similar_properties[:6]\n    \n    return render_template('predict.html', price_range=price_range, similar_properties=similar_properties)\n\n","size_bytes":4842},"app/services/__init__.py":{"content":"# Services package","size_bytes":18},"app/services/ai_service.py":{"content":"import json\nimport re\nimport os\nfrom typing import List, Dict, Optional, Tuple\nfrom dotenv import load_dotenv\nfrom app.models import PropertyRepository\nfrom app.utils.search_utils import extract_search_criteria, filter_properties_strict\n\n# Load environment variables\nload_dotenv()\n\n# Import Gemini AI integration\ntry:\n    from google import genai\n    from google.genai import types\n    api_key = os.getenv(\"GEMINI_API_KEY\")\n    if api_key and api_key != \"your_gemini_api_key_here\":\n        client = genai.Client(api_key=api_key)\n        GEMINI_AVAILABLE = True\n    else:\n        raise ValueError(\"GEMINI_API_KEY not found or not configured\")\nexcept Exception as e:\n    print(f\"Gemini AI not available: {e}\")\n    GEMINI_AVAILABLE = False\n    client = None\n    types = None\n\nclass AIPropertySearch:\n    \"\"\"Enhanced AI-powered property search with deterministic filtering\"\"\"\n    \n    @staticmethod\n    def search_properties(query: str) -> Dict:\n        \"\"\"\n        Search properties using AI with deterministic pre/post filtering\n        Returns: Dict with properties, explanation, and ai_powered flag\n        \"\"\"\n        if not query.strip():\n            return {\n                'properties': PropertyRepository.load_properties()[:6],\n                'explanation': 'Menampilkan beberapa properti terbaru.',\n                'ai_powered': False\n            }\n        \n        properties = PropertyRepository.load_properties()\n        \n        # Step 1: Pre-filter with deterministic rules\n        criteria = extract_search_criteria(query)\n        pre_filtered = filter_properties_strict(properties, criteria)\n        \n        # Step 2: Check for non-property queries\n        if AIPropertySearch._is_non_property_query(query):\n            return {\n                'properties': [],\n                'explanation': 'Silakan berikan kriteria pencarian properti yang lebih spesifik, seperti budget, jumlah kamar, atau lokasi yang diinginkan.',\n                'ai_powered': True\n            }\n        \n        # Step 3: Use AI if available for context understanding\n        if GEMINI_AVAILABLE and client and len(pre_filtered) > 0:\n            try:\n                ai_result = AIPropertySearch._get_ai_recommendations(query, pre_filtered)\n                if ai_result:\n                    return ai_result\n            except Exception as e:\n                print(f\"AI search failed: {e}\")\n        \n        # Step 4: Fallback to deterministic results\n        return {\n            'properties': pre_filtered[:5],\n            'explanation': f\"Ditemukan {len(pre_filtered)} properti yang sesuai kriteria Anda.\",\n            'ai_powered': False\n        }\n    \n    @staticmethod\n    def _is_non_property_query(query: str) -> bool:\n        \"\"\"Check if query is non-property related\"\"\"\n        non_property_queries = ['hai', 'hello', 'halo', 'hi', 'apa kabar', 'terima kasih', 'thanks', 'bye']\n        return query.lower().strip() in non_property_queries\n    \n    @staticmethod\n    def _get_ai_recommendations(query: str, filtered_properties: List[Dict]) -> Optional[Dict]:\n        \"\"\"Get AI recommendations from pre-filtered properties\"\"\"\n        if not filtered_properties:\n            return None\n            \n        # Create simplified context for AI\n        property_context = []\n        for i, prop in enumerate(filtered_properties):\n            context_item = {\n                'index': i,\n                'alamat': prop.get('alamat', 'N/A'),\n                'kelurahan': prop.get('kelurahan', 'N/A'),\n                'kecamatan': prop.get('kecamatan', 'N/A'),\n                'harga': prop.get('harga', 0),\n                'kamar_tidur': prop.get('kamar_tidur', 0),\n                'kamar_mandi': prop.get('kamar_mandi', 0),\n                'luas_tanah': prop.get('luas_tanah', 0),\n                'luas_bangunan': prop.get('luas_bangunan', 0),\n                'judul_properti': prop.get('judul_properti', 'N/A')\n            }\n            property_context.append(context_item)\n        \n        system_prompt = f\"\"\"Anda adalah asisten properti yang membantu memilih dari properti yang SUDAH DIFILTER berdasarkan kriteria lokasi dan spesifikasi.\n\nProperti yang tersedia (sudah sesuai kriteria dasar):\n{json.dumps(property_context, indent=2)}\n\nQuery pengguna: \"{query}\"\n\nTUGAS: Pilih maksimal 3 properti TERBAIK dari list di atas yang paling sesuai dengan query.\n\nATURAN PRIORITAS:\n- HANYA pilih dari properti yang sudah disediakan (index 0 hingga {len(filtered_properties)-1})\n- Jika query menyebutkan lokasi spesifik (kelurahan/daerah) → prioritaskan lokasi yang sama\n- Jika query menyebutkan \"murah\" → pilih yang harga terendah\n- Jika query menyebutkan \"besar\" → pilih yang luas terbesar\n- Jika query menyebutkan jumlah kamar → prioritaskan yang sesuai\n- Jika tidak ada preferensi khusus → pilih yang paling sesuai konteks\n\nCONTOH KELURAHAN:\n- \"gunung ibul\" = properti di Gunung Ibul\n- \"patih galung\" = properti di Patih Galung\n- \"majasari\" = properti di Majasari\n- \"sukajadi\" = properti di Sukajadi\n- \"muara dua\" = properti di Muara Dua\n- \"wonosari\" = properti di Wonosari\n- \"cambai\" = properti di Cambai\n\nCONTOH KECAMATAN:\n- \"prabumulih timur\" = properti di Kecamatan Prabumulih Timur\n- \"prabumulih barat\" = properti di Kecamatan Prabumulih Barat\n- \"prabumulih selatan\" = properti di Kecamatan Prabumulih Selatan\n- \"prabumulih utara\" = properti di Kecamatan Prabumulih Utara\n- \"cambai\" = properti di Kecamatan Cambai\n- \"rambang kapak tengah\" = properti di Kecamatan Rambang Kapak Tengah\n\nResponlah HANYA dengan format JSON:\n{{\"property_indices\": [0, 1, 2], \"explanation\": \"Penjelasan singkat mengapa dipilih berdasarkan kriteria lokasi dan spesifikasi\"}}\"\"\"\n\n        try:\n            response = client.models.generate_content(\n                model=\"gemini-2.5-flash\",\n                contents=[types.Content(role=\"user\", parts=[types.Part(text=system_prompt)])]\n            )\n            \n            if response.text:\n                ai_result = json.loads(response.text.strip())\n                selected_indices = ai_result.get('property_indices', [])\n                explanation = ai_result.get('explanation', '')\n                \n                # Validate indices and get properties\n                selected_properties = []\n                for idx in selected_indices:\n                    if 0 <= idx < len(filtered_properties):\n                        selected_properties.append(filtered_properties[idx])\n                \n                return {\n                    'properties': selected_properties,\n                    'explanation': explanation if selected_properties else \"Tidak ada properti yang sesuai dengan kriteria pencarian Anda.\",\n                    'ai_powered': True\n                }\n        except (json.JSONDecodeError, Exception):\n            pass\n        \n        return None\n\ndef gemini_chat_response(message: str, context: Optional[str] = None) -> str:\n    \"\"\"Generate chatbot response using Gemini AI\"\"\"\n    if not GEMINI_AVAILABLE or not client:\n        return \"Maaf, layanan chatbot AI sedang tidak tersedia. Silakan hubungi admin untuk mengkonfigurasi GEMINI_API_KEY.\"\n    \n    try:\n        # Create context about properties\n        properties = PropertyRepository.load_properties()\n        property_context = f\"Available properties count: {len(properties)}\"\n        if properties:\n            prices = [float(p.get('harga', 0)) for p in properties if p.get('harga')]\n            if prices:\n                avg_price = sum(prices) / len(prices)\n                property_context += f\", Average price: Rp {avg_price:,.0f}\"\n        \n        system_prompt = f\"\"\"You are a helpful real estate assistant for a property recommendation system. \n        Context: {property_context}\n        \n        Help users with:\n        - Property searches and recommendations\n        - Price predictions and market analysis\n        - Location and facility information\n        - Answering questions about property features\n        \n        Be friendly, informative, and helpful. Respond in Bahasa Indonesia when appropriate.\"\"\"\n        \n        response = client.models.generate_content(\n            model=\"gemini-2.5-flash\",\n            contents=[\n                types.Content(role=\"user\", parts=[types.Part(text=f\"{system_prompt}\\n\\nUser question: {message}\")])\n            ]\n        )\n        \n        return response.text if response.text else \"Maaf, saya tidak dapat memproses pertanyaan Anda saat ini.\"\n        \n    except Exception as e:\n        return \"Maaf, terjadi kesalahan pada sistem search. Silakan coba lagi.\"","size_bytes":8542},"app/services/ml_service.py":{"content":"import pandas as pd\nimport numpy as np\nfrom sklearn.ensemble import RandomForestRegressor\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import mean_absolute_error, r2_score\nimport pickle\nfrom typing import Optional, Dict, Any\nfrom app.models import PropertyRepository, BasePriceRepository, encode_categorical\nfrom app.config import Config\n\nclass MLPredictionService:\n    \"\"\"Machine Learning service for property price prediction\"\"\"\n    \n    def __init__(self):\n        self.model: Optional[RandomForestRegressor] = None\n        self.scaler: Optional[StandardScaler] = None\n        self.feature_columns = Config.FEATURE_COLUMNS\n    \n    def prepare_ml_data(self) -> Optional[pd.DataFrame]:\n        \"\"\"Prepare data for machine learning\"\"\"\n        properties = PropertyRepository.load_properties()\n        if len(properties) < 5:  # Need minimum data for training\n            return None\n        \n        # Prepare dataset\n        data = []\n        for prop in properties:\n            if prop.get('harga') and all(key in prop for key in ['luas_tanah', 'luas_bangunan']):\n                row = [\n                    float(prop['luas_tanah']),\n                    float(prop['luas_bangunan']),\n                    int(prop.get('kamar_tidur', 2)),\n                    int(prop.get('kamar_mandi', 1)),\n                    int(prop.get('carport', 0)),\n                    int(prop.get('tahun_dibangun', 2020)),\n                    int(prop.get('lantai', 1)),\n                    float(prop.get('jarak_sekolah', 1000)),\n                    float(prop.get('jarak_rs', 2000)),\n                    float(prop.get('jarak_pasar', 1500)),\n                    encode_categorical(prop.get('jenis_jalan'), Config.JENIS_JALAN_MAP),\n                    encode_categorical(prop.get('kondisi'), Config.KONDISI_MAP),\n                    encode_categorical(prop.get('sertifikat'), Config.SERTIFIKAT_MAP),\n                    float(prop['harga'])\n                ]\n                data.append(row)\n        \n        if len(data) < 5:\n            return None\n            \n        columns = self.feature_columns + ['harga']\n        df = pd.DataFrame(data, columns=columns)\n        return df\n    \n    def train_model(self) -> bool:\n        \"\"\"Train the machine learning model\"\"\"\n        df = self.prepare_ml_data()\n        if df is None:\n            return False\n        \n        # Prepare features and target\n        X = df[self.feature_columns]\n        y = df['harga']\n        \n        # Scale features\n        self.scaler = StandardScaler()\n        X_scaled = self.scaler.fit_transform(X)\n        \n        # Train model\n        self.model = RandomForestRegressor(n_estimators=100, random_state=42)\n        self.model.fit(X_scaled, y)\n        \n        # Save model\n        try:\n            with open('models/price_model.pkl', 'wb') as f:\n                pickle.dump({'model': self.model, 'scaler': self.scaler}, f)\n            return True\n        except Exception as e:\n            print(f\"Error saving model: {e}\")\n            return False\n    \n    def load_model(self) -> bool:\n        \"\"\"Load the trained ML model\"\"\"\n        try:\n            with open('models/price_model.pkl', 'rb') as f:\n                model_data = pickle.load(f)\n                self.model = model_data['model']\n                self.scaler = model_data['scaler']\n            return True\n        except FileNotFoundError:\n            return self.train_model()\n        except Exception as e:\n            print(f\"Error loading model: {e}\")\n            return False\n    \n    def predict_price(self, property_data: Dict[str, Any]) -> Optional[float]:\n        \"\"\"Predict house price using hybrid ML + base price model\"\"\"\n        # First try ML prediction\n        ml_prediction = self._get_ml_prediction(property_data)\n        \n        # Always calculate base price prediction\n        base_prediction = self._get_base_price_prediction(property_data)\n        \n        # If ML model available, use weighted average\n        if ml_prediction is not None and base_prediction is not None:\n            # 70% ML, 30% base price for balanced prediction\n            final_prediction = (0.7 * ml_prediction) + (0.3 * base_prediction)\n            return max(0, final_prediction)\n        elif base_prediction is not None:\n            # Fallback to base price calculation\n            return base_prediction\n        \n        return ml_prediction\n    \n    def _get_ml_prediction(self, property_data: Dict[str, Any]) -> Optional[float]:\n        \"\"\"Get ML model prediction\"\"\"\n        if self.model is None:\n            if not self.load_model():\n                return None\n        \n        # Prepare input data\n        tahun_dibangun = int(property_data.get('tahun_dibangun', 2020))\n        \n        features = [\n            float(property_data.get('luas_tanah', 100)),\n            float(property_data.get('luas_bangunan', 80)),\n            int(property_data.get('kamar_tidur', 2)),\n            int(property_data.get('kamar_mandi', 1)),\n            int(property_data.get('carport', 0)),\n            tahun_dibangun,\n            int(property_data.get('lantai', 1)),\n            float(property_data.get('jarak_sekolah', 1000)),\n            float(property_data.get('jarak_rs', 2000)),\n            float(property_data.get('jarak_pasar', 1500)),\n            encode_categorical(property_data.get('jenis_jalan'), Config.JENIS_JALAN_MAP),\n            encode_categorical(property_data.get('kondisi'), Config.KONDISI_MAP),\n            encode_categorical(property_data.get('sertifikat'), Config.SERTIFIKAT_MAP)\n        ]\n        \n        print(f\"Debug ML - Year built feature: {tahun_dibangun}\")\n        \n        # Scale and predict\n        if self.scaler is not None and self.model is not None:\n            try:\n                features_scaled = self.scaler.transform([features])\n                prediction = self.model.predict(features_scaled)[0]\n                return max(0, prediction)\n            except Exception as e:\n                print(f\"Error predicting price: {e}\")\n                return None\n        \n        return None\n    \n    def _get_base_price_prediction(self, property_data: Dict[str, Any]) -> Optional[float]:\n        \"\"\"Calculate price using base price methodology\"\"\"\n        try:\n            base_prices = BasePriceRepository.load_base_prices()\n            \n            # Basic calculation\n            luas_tanah = float(property_data.get('luas_tanah', 100))\n            luas_bangunan = float(property_data.get('luas_bangunan', 80))\n            kamar_tidur = int(property_data.get('kamar_tidur', 2))\n            kamar_mandi = int(property_data.get('kamar_mandi', 1))\n            lantai = int(property_data.get('lantai', 1))\n            tahun_dibangun = int(property_data.get('tahun_dibangun', 2020))\n            \n            # Base price calculation\n            land_value = luas_tanah * base_prices['base_price_per_sqm_land']\n            building_value = luas_bangunan * base_prices['base_price_per_sqm_building']\n            room_bonus = kamar_tidur * base_prices['room_multiplier']\n            bathroom_bonus = kamar_mandi * base_prices['bathroom_multiplier']\n            floor_bonus = lantai * base_prices.get('floor_multiplier', 10000000)  # Default 10M per floor\n            \n            # Calculate age factor - newer buildings are more valuable\n            current_year = 2025\n            building_age = current_year - tahun_dibangun\n            \n            # Age multiplier: newer = higher value, older = lower value\n            # Buildings 0-5 years: 100% value\n            # Buildings 6-10 years: 95% value  \n            # Buildings 11-15 years: 90% value\n            # Buildings 16-20 years: 85% value\n            # Buildings >20 years: 80% value\n            if building_age <= 5:\n                age_multiplier = 1.0\n            elif building_age <= 10:\n                age_multiplier = 0.95\n            elif building_age <= 15:\n                age_multiplier = 0.90\n            elif building_age <= 20:\n                age_multiplier = 0.85\n            else:\n                age_multiplier = 0.80\n            \n            print(f\"Debug - Year built: {tahun_dibangun}, Age: {building_age}, Age multiplier: {age_multiplier}\")\n            \n            base_total = (land_value + building_value + room_bonus + bathroom_bonus + floor_bonus) * age_multiplier\n            \n            # Apply multipliers\n            kondisi = property_data.get('kondisi', 'baik')\n            condition_mult = base_prices['condition_multipliers'].get(kondisi, 1.0)\n            \n            jenis_jalan = property_data.get('jenis_jalan', 'jalan_sedang')\n            road_mult = base_prices['road_multipliers'].get(jenis_jalan, 1.0)\n            \n            sertifikat = property_data.get('sertifikat', 'hgb')\n            cert_mult = base_prices['certificate_multipliers'].get(sertifikat, 1.0)\n            \n            final_price = base_total * condition_mult * road_mult * cert_mult\n            \n            return max(0, final_price)\n            \n        except Exception as e:\n            print(f\"Error calculating base price: {e}\")\n            return None\n    \n    def get_price_range(self, property_data: Dict[str, Any]) -> Optional[Dict[str, float]]:\n        \"\"\"Get price range (min, max, predicted)\"\"\"\n        predicted_price = self.predict_price(property_data)\n        if predicted_price is None:\n            return None\n        \n        # Calculate range (±20% from predicted)\n        variation = predicted_price * 0.2\n        return {\n            'min_price': max(0, predicted_price - variation),\n            'max_price': predicted_price + variation,\n            'predicted_price': predicted_price\n        }\n\n# Global ML service instance\nml_service = MLPredictionService()","size_bytes":9786},"app/utils/__init__.py":{"content":"# Utils package","size_bytes":15},"app/utils/phone_utils.py":{"content":"import re\nfrom urllib.parse import quote_plus\n\ndef normalize_indonesian_phone(phone_number):\n    \"\"\"\n    Normalize Indonesian phone numbers for WhatsApp links\n    Converts various formats to proper international format (62XXXXXXXXX)\n    \"\"\"\n    if not phone_number:\n        return None\n    \n    # Remove all non-digit characters\n    clean_number = re.sub(r'\\D', '', phone_number)\n    \n    if not clean_number:\n        return None\n    \n    # Handle different formats\n    if clean_number.startswith('62'):\n        # Already in international format\n        return clean_number\n    elif clean_number.startswith('0'):\n        # Local format (08xxx) -> convert to international (62xxx)\n        return '62' + clean_number[1:]\n    else:\n        # Assume it's missing the country code and leading 0\n        return '62' + clean_number\n    \ndef create_whatsapp_link(phone_number, seller_name, property_title):\n    \"\"\"\n    Create a properly formatted WhatsApp link with normalized phone and encoded message\n    \"\"\"\n    normalized_phone = normalize_indonesian_phone(phone_number)\n    \n    if not normalized_phone:\n        return None\n    \n    # Create message text\n    message = f\"Halo {seller_name or 'Penjual'}, saya tertarik dengan properti {property_title} yang sedang dijual. Bisa kita diskusi lebih lanjut?\"\n    \n    # URL encode the message\n    encoded_message = quote_plus(message)\n    \n    # Create WhatsApp link\n    whatsapp_link = f\"https://wa.me/{normalized_phone}?text={encoded_message}\"\n    \n    return whatsapp_link","size_bytes":1517},"app/utils/search_utils.py":{"content":"import re\nfrom typing import Dict, List, Optional, Any\n\ndef extract_search_criteria(query: str) -> Dict[str, Any]:\n    \"\"\"\n    Extract search criteria from query using enhanced NLP patterns\n    Returns: Dict with extracted criteria\n    \"\"\"\n    query_lower = query.lower()\n    criteria = {}\n    \n    # Normalize common conversational patterns\n    query_lower = re.sub(r'\\b(ada\\s*ga|ada\\s*tidak|ada\\s*ngga|ada\\s*enggak)\\b', '', query_lower)\n    query_lower = re.sub(r'\\b(kalau|kalo|gimana|bagaimana|berapa)\\b', '', query_lower)\n    query_lower = re.sub(r'\\b(rumah|properti|yang|dengan|punya|memiliki)\\b', '', query_lower)\n    query_lower = query_lower.strip()\n    \n    # Extract budget (enhanced patterns)\n    budget_patterns = [\n        r'(\\d+)\\s*juta',  # \"500 juta\"\n        r'budget\\s*(\\d+)',  # \"budget 500\"\n        r'(\\d+)\\s*m\\b',  # \"500m\"\n        r'harga\\s*(\\d+)',  # \"harga 500\"\n        r'(\\d+)\\s*milyar',  # \"1 milyar\"\n    ]\n    \n    for pattern in budget_patterns:\n        matches = re.findall(pattern, query_lower)\n        if matches:\n            budget = int(matches[0]) * 1000000\n            criteria['budget'] = budget\n            criteria['budget_range'] = (budget * 0.8, budget * 1.2)  # ±20%\n            break\n    \n    # Extract bedroom count (enhanced patterns)\n    room_patterns = [\n        r'(\\d+)\\s*kamar\\s*tidur',  # \"2 kamar tidur\"\n        r'(\\d+)\\s*kt\\b',           # \"2 kt\"\n        r'kt\\s*(\\d+)',             # \"kt 2\"\n        r'kamar\\s*tidur\\s*(\\d+)',  # \"kamar tidur 2\"\n        r'(\\d+)\\s*bedroom',        # \"2 bedroom\"\n        r'bedroom\\s*(\\d+)',        # \"bedroom 2\"\n        # Handle cases where \"kamar\" might refer to bedroom in context\n        r'(?<!mandi\\s)(\\d+)\\s*kamar(?!\\s*mandi)',  # \"2 kamar\" but not \"2 kamar mandi\"\n    ]\n    \n    for pattern in room_patterns:\n        matches = re.findall(pattern, query_lower)\n        if matches:\n            criteria['kamar_tidur'] = int(matches[0])\n            break\n    \n    # Extract bathroom count (enhanced patterns)\n    bathroom_patterns = [\n        r'(\\d+)\\s*kamar\\s*mandi',  # \"2 kamar mandi\"\n        r'(\\d+)\\s*km\\b',           # \"2 km\"\n        r'km\\s*(\\d+)',             # \"km 2\"\n        r'kamar\\s*mandi\\s*(\\d+)',  # \"kamar mandi 2\"\n        r'(\\d+)\\s*bathroom',       # \"2 bathroom\"\n        r'bathroom\\s*(\\d+)',       # \"bathroom 2\"\n        r'(\\d+)\\s*wc\\b',           # \"2 wc\"\n        r'wc\\s*(\\d+)',             # \"wc 2\"\n    ]\n    \n    for pattern in bathroom_patterns:\n        matches = re.findall(pattern, query_lower)\n        if matches:\n            criteria['kamar_mandi'] = int(matches[0])\n            break\n    \n    # Extract area/size requirements\n    luas_patterns = [\n        r'(\\d+)\\s*m2?\\s*tanah',     # \"100 m2 tanah\"\n        r'tanah\\s*(\\d+)\\s*m2?',     # \"tanah 100 m2\"\n        r'luas\\s*tanah\\s*(\\d+)',    # \"luas tanah 100\"\n        r'(\\d+)\\s*meter\\s*tanah',   # \"100 meter tanah\"\n    ]\n    \n    for pattern in luas_patterns:\n        matches = re.findall(pattern, query_lower)\n        if matches:\n            criteria['min_luas_tanah'] = int(matches[0])\n            break\n    \n    building_patterns = [\n        r'(\\d+)\\s*m2?\\s*bangunan',     # \"100 m2 bangunan\"\n        r'bangunan\\s*(\\d+)\\s*m2?',     # \"bangunan 100 m2\"\n        r'luas\\s*bangunan\\s*(\\d+)',    # \"luas bangunan 100\"\n        r'(\\d+)\\s*meter\\s*bangunan',   # \"100 meter bangunan\"\n    ]\n    \n    for pattern in building_patterns:\n        matches = re.findall(pattern, query_lower)\n        if matches:\n            criteria['min_luas_bangunan'] = int(matches[0])\n            break\n    \n    # Extract carport requirements\n    carport_patterns = [\n        r'(\\d+)\\s*carport',         # \"1 carport\"\n        r'carport\\s*(\\d+)',         # \"carport 1\"\n        r'(\\d+)\\s*garasi',          # \"1 garasi\"\n        r'garasi\\s*(\\d+)',          # \"garasi 1\"\n    ]\n    \n    for pattern in carport_patterns:\n        matches = re.findall(pattern, query_lower)\n        if matches:\n            criteria['min_carport'] = int(matches[0])\n            break\n    \n    # Extract location/facility requirements (enhanced)\n    if any(term in query_lower for term in ['dekat sekolah', 'near school', 'sekolah', 'deket sekolah']):\n        criteria['max_distance_school'] = 500  # 500m\n    \n    if any(term in query_lower for term in ['dekat rumah sakit', 'dekat rs', 'near hospital', 'hospital', 'deket rs']):\n        criteria['max_distance_hospital'] = 1000  # 1km\n    \n    if any(term in query_lower for term in ['dekat pasar', 'near market', 'pasar', 'deket pasar']):\n        criteria['max_distance_market'] = 800  # 800m\n    \n    # Extract condition preferences (enhanced)\n    if any(term in query_lower for term in ['baru', 'new', 'brand new']):\n        criteria['kondisi'] = 'baru'\n    elif any(term in query_lower for term in ['baik', 'good', 'bagus']):\n        criteria['kondisi'] = 'baik'\n    elif any(term in query_lower for term in ['renovasi', 'butuh renovasi']):\n        criteria['kondisi'] = 'butuh_renovasi'\n    \n    # Extract certificate preferences\n    if any(term in query_lower for term in ['shm', 'sertifikat hak milik']):\n        criteria['sertifikat'] = 'SHM'\n    elif any(term in query_lower for term in ['hgb', 'hak guna bangunan']):\n        criteria['sertifikat'] = 'HGB'\n    \n    # Extract kelurahan/location preferences (enhanced with actual data)\n    kelurahan_list = [\n        'majasari', 'sukaraja', 'gunung ibul', 'gunungibul', 'patih galung',\n        'wonosari', 'gunung kemala', 'sukajadi', 'karang bindu', 'kel. tanjung telang',\n        'tanjung telang', 'tanjung raman', 'cambai', 'muara dua', 'anak petai',\n        'pangkul', 'karang jaya', 'gunung ibul barat', 'mangga'\n    ]\n    \n    # Extract kecamatan/district preferences\n    kecamatan_list = [\n        'prabumulih selatan', 'prabumulih timur', 'prabumulih barat', \n        'prabumulih utara', 'cambai', 'rambang kapak tengah'\n    ]\n    \n    # Extract location with various patterns\n    location_patterns = [\n        r'di\\s+kelurahan\\s+([a-zA-Z\\s]+)',      # \"di kelurahan gunung ibul\"\n        r'kelurahan\\s+([a-zA-Z\\s]+)',          # \"kelurahan gunung ibul\"\n        r'di\\s+kecamatan\\s+([a-zA-Z\\s]+)',     # \"di kecamatan prabumulih timur\"\n        r'kecamatan\\s+([a-zA-Z\\s]+)',          # \"kecamatan prabumulih timur\"\n        r'di\\s+([a-zA-Z\\s]+)',                 # \"di gunung ibul\"\n        r'daerah\\s+([a-zA-Z\\s]+)',             # \"daerah gunung ibul\"\n        r'wilayah\\s+([a-zA-Z\\s]+)',            # \"wilayah gunung ibul\"\n        r'area\\s+([a-zA-Z\\s]+)',               # \"area gunung ibul\"\n    ]\n    \n    # Try pattern matching first for kelurahan\n    for pattern in location_patterns:\n        matches = re.findall(pattern, query_lower)\n        if matches:\n            location = matches[0].strip()\n            # Check if the extracted location is in our known kelurahan list\n            for kelurahan in kelurahan_list:\n                if kelurahan in location.lower() or location.lower() in kelurahan:\n                    criteria['kelurahan'] = kelurahan.replace('gunungibul', 'gunung ibul').replace('kel. ', '').title()\n                    break\n            # Check if the extracted location is in our known kecamatan list\n            if 'kelurahan' not in criteria:\n                for kecamatan in kecamatan_list:\n                    if kecamatan in location.lower() or location.lower() in kecamatan:\n                        criteria['kecamatan'] = kecamatan.title()\n                        break\n            if 'kelurahan' in criteria or 'kecamatan' in criteria:\n                break\n    \n    # Fallback to direct keyword matching for kelurahan\n    if 'kelurahan' not in criteria and 'kecamatan' not in criteria:\n        for kelurahan in kelurahan_list:\n            if kelurahan in query_lower:\n                criteria['kelurahan'] = kelurahan.replace('gunungibul', 'gunung ibul').replace('kel. ', '').title()\n                break\n        \n        # If no kelurahan found, try kecamatan\n        if 'kelurahan' not in criteria:\n            for kecamatan in kecamatan_list:\n                if kecamatan in query_lower:\n                    criteria['kecamatan'] = kecamatan.title()\n                    break\n    \n    # Extract price preferences\n    if any(term in query_lower for term in ['murah', 'cheap', 'ekonomis']):\n        criteria['price_preference'] = 'low'\n    elif any(term in query_lower for term in ['mahal', 'expensive', 'mewah', 'luxury']):\n        criteria['price_preference'] = 'high'\n    \n    # Extract size preferences\n    if any(term in query_lower for term in ['besar', 'luas', 'big', 'large']):\n        criteria['size_preference'] = 'large'\n    elif any(term in query_lower for term in ['kecil', 'small', 'compact']):\n        criteria['size_preference'] = 'small'\n    \n    return criteria\n\ndef filter_properties_strict(properties: List[Dict], criteria: Dict[str, Any]) -> List[Dict]:\n    \"\"\"\n    Apply strict deterministic filtering based on extracted criteria\n    \"\"\"\n    if not criteria:\n        return properties\n    \n    filtered = []\n    \n    for prop in properties:\n        matches = True\n        \n        # EXACT bedroom match (critical fix for the reported issue)\n        if 'kamar_tidur' in criteria:\n            prop_rooms = prop.get('kamar_tidur', 0)\n            required_rooms = criteria['kamar_tidur']\n            # For \"2 kamar tidur\" query, only show properties with EXACTLY 2 bedrooms\n            if prop_rooms != required_rooms:\n                matches = False\n        \n        # EXACT bathroom match\n        if 'kamar_mandi' in criteria:\n            prop_bathrooms = prop.get('kamar_mandi', 0)\n            required_bathrooms = criteria['kamar_mandi']\n            if prop_bathrooms != required_bathrooms:\n                matches = False\n        \n        # Area/size filtering\n        if 'min_luas_tanah' in criteria:\n            prop_luas_tanah = prop.get('luas_tanah', 0)\n            if prop_luas_tanah < criteria['min_luas_tanah']:\n                matches = False\n        \n        if 'min_luas_bangunan' in criteria:\n            prop_luas_bangunan = prop.get('luas_bangunan', 0)\n            if prop_luas_bangunan < criteria['min_luas_bangunan']:\n                matches = False\n        \n        # Carport filtering\n        if 'min_carport' in criteria:\n            prop_carport = prop.get('carport', 0)\n            if prop_carport < criteria['min_carport']:\n                matches = False\n        \n        # Location/kelurahan filtering (improved with fuzzy matching)\n        if 'kelurahan' in criteria:\n            prop_kelurahan = prop.get('kelurahan', '').lower().strip()\n            criteria_kelurahan = criteria['kelurahan'].lower().strip()\n            \n            # Exact match\n            if prop_kelurahan == criteria_kelurahan:\n                pass  # matches = True\n            # Fuzzy matching for variations\n            elif 'gunung ibul' in criteria_kelurahan and 'gunung ibul' in prop_kelurahan:\n                pass  # matches = True\n            elif criteria_kelurahan in prop_kelurahan or prop_kelurahan in criteria_kelurahan:\n                pass  # matches = True\n            else:\n                matches = False\n        \n        # Location/kecamatan filtering\n        if 'kecamatan' in criteria:\n            prop_kecamatan = prop.get('kecamatan', '').lower().strip()\n            criteria_kecamatan = criteria['kecamatan'].lower().strip()\n            \n            # Exact match\n            if prop_kecamatan == criteria_kecamatan:\n                pass  # matches = True\n            # Fuzzy matching for variations\n            elif criteria_kecamatan in prop_kecamatan or prop_kecamatan in criteria_kecamatan:\n                pass  # matches = True\n            else:\n                matches = False\n        \n        # Certificate filtering\n        if 'sertifikat' in criteria:\n            prop_sertifikat = prop.get('sertifikat', '')\n            if prop_sertifikat.upper() != criteria['sertifikat'].upper():\n                matches = False\n        \n        # Budget range filtering\n        if 'budget_range' in criteria:\n            prop_price = prop.get('harga', 0)\n            if prop_price == 0:  # Skip properties without price\n                matches = False\n            else:\n                min_budget, max_budget = criteria['budget_range']\n                if not (min_budget <= prop_price <= max_budget):\n                    matches = False\n        \n        # Distance filtering (strict)\n        if 'max_distance_school' in criteria:\n            if prop.get('jarak_sekolah', 9999) > criteria['max_distance_school']:\n                matches = False\n        \n        if 'max_distance_hospital' in criteria:\n            if prop.get('jarak_rs', 9999) > criteria['max_distance_hospital']:\n                matches = False\n        \n        if 'max_distance_market' in criteria:\n            if prop.get('jarak_pasar', 9999) > criteria['max_distance_market']:\n                matches = False\n        \n        # Condition filtering\n        if 'kondisi' in criteria:\n            prop_kondisi = prop.get('kondisi', '')\n            if prop_kondisi.lower() != criteria['kondisi'].lower():\n                matches = False\n        \n        if matches:\n            filtered.append(prop)\n    \n    # Apply preference-based sorting\n    if 'price_preference' in criteria:\n        if criteria['price_preference'] == 'low':\n            filtered.sort(key=lambda p: p.get('harga', float('inf')))\n        elif criteria['price_preference'] == 'high':\n            filtered.sort(key=lambda p: p.get('harga', 0), reverse=True)\n    \n    if 'size_preference' in criteria:\n        if criteria['size_preference'] == 'large':\n            filtered.sort(key=lambda p: p.get('luas_tanah', 0) + p.get('luas_bangunan', 0), reverse=True)\n        elif criteria['size_preference'] == 'small':\n            filtered.sort(key=lambda p: p.get('luas_tanah', 0) + p.get('luas_bangunan', 0))\n    \n    return filtered\n\ndef is_property_related_query(query: str) -> bool:\n    \"\"\"Check if query contains property-related keywords (enhanced)\"\"\"\n    property_keywords = [\n        'rumah', 'juta', 'kamar', 'budget', 'luas', 'sekolah', 'hospital', 'pasar', \n        'properti', 'beli', 'cari', 'house', 'bedroom', 'bathroom', 'price', 'search',\n        'carport', 'garasi', 'tanah', 'bangunan', 'sertifikat', 'kelurahan', 'alamat',\n        'kt', 'km', 'wc', 'm2', 'meter', 'dekat', 'deket', 'jarak', 'kondisi',\n        'shm', 'hgb', 'tahun', 'dibangun', 'renovasi', 'mandi', 'tidur', 'ada',\n        'di', 'daerah', 'wilayah', 'area', 'lokasi', 'kecamatan',\n        'mencari', 'sedang', 'butuh', 'ingin', 'perlu', 'mau',\n        # Kelurahan keywords\n        'majasari', 'sukaraja', 'gunung ibul', 'patih galung', 'wonosari',\n        'gunung kemala', 'sukajadi', 'karang bindu', 'tanjung telang', 'tanjung raman',\n        'cambai', 'muara dua', 'anak petai', 'pangkul', 'karang jaya', 'gunung ibul barat', 'mangga',\n        # Kecamatan keywords\n        'prabumulih selatan', 'prabumulih timur', 'prabumulih barat', \n        'prabumulih utara', 'rambang kapak tengah'\n    ]\n    query_lower = query.lower()\n    return any(keyword in query_lower for keyword in property_keywords)","size_bytes":15112},"replit.md":{"content":"# Prediksi Harga Rumah - Real Estate Price Prediction App\n\n## Overview\nThis is a Flask-based real estate property management and price prediction application for properties in Prabumulih, Indonesia. It uses Machine Learning (Random Forest) and AI (Google Gemini) to help users find properties and predict property prices.\n\n## Project Architecture\n\n### Technology Stack\n- **Backend Framework**: Flask 3.1.2\n- **Package Manager**: uv (Python package manager)\n- **Python Version**: 3.11\n- **ML Framework**: scikit-learn 1.7.2\n- **AI Service**: Google Gemini AI\n- **Production Server**: Gunicorn\n\n### Project Structure\n```\n.\n├── app/\n│   ├── blueprints/          # Flask blueprints (routes)\n│   │   ├── main.py         # Main user-facing routes\n│   │   ├── admin.py        # Admin panel routes\n│   │   └── api.py          # API endpoints\n│   ├── services/           # Business logic\n│   │   ├── ai_service.py   # Gemini AI integration\n│   │   └── ml_service.py   # ML price prediction\n│   ├── utils/              # Utility functions\n│   ├── config.py           # Application configuration\n│   └── models.py           # Data models (JSON-based)\n├── data/\n│   ├── properties.json     # Property database\n│   └── base_prices.json    # Base price settings\n├── models/\n│   └── price_model.pkl     # Trained ML model\n├── static/                 # Static files (images, CSS, JS)\n├── templates/              # HTML templates\n└── main.py                 # Application entry point\n```\n\n## Features\n\n### User Features\n1. **Property Search**: Natural language property search using AI\n2. **Property Listings**: Browse and filter properties by budget and location\n3. **Price Prediction**: ML-based property price prediction based on:\n   - Land area (luas tanah)\n   - Building area (luas bangunan)\n   - Number of bedrooms/bathrooms\n   - Building condition\n   - Certificate type\n   - Location factors\n\n### Admin Features\n1. **Property Management**: Add, edit, delete properties\n2. **Base Price Settings**: Configure pricing parameters\n3. **Prediction Dashboard**: View price predictions\n\n## Data Storage\nThe application uses JSON file-based storage:\n- **Properties**: Stored in `data/properties.json`\n- **Base Prices**: Stored in `data/base_prices.json`\n\n## Configuration\n\n### Environment Variables\nThe following environment variables are configured in `.env`:\n- `GEMINI_API_KEY`: API key for Google Gemini AI\n- `GOOGLE_MAPS_API_KEY`: API key for Google Maps (optional)\n- `SESSION_SECRET`: Flask session secret key\n\n### ML Model\n- **Type**: Random Forest Regressor\n- **Training Version**: scikit-learn 1.5.2\n- **Current Version**: scikit-learn 1.7.2 (backward compatible with warnings)\n- **Location**: `models/price_model.pkl`\n\n## Development\n\n### Running Locally\nThe application runs on port 5000:\n```bash\nuv run python main.py\n```\n\n### Deployment\nConfigured for Replit Autoscale deployment using Gunicorn:\n```bash\ngunicorn --bind=0.0.0.0:5000 --reuse-port main:app\n```\n\n## Recent Changes (October 2025)\n- Migrated to Replit environment\n- Configured uv package manager\n- Set up development workflow on port 5000\n- Configured production deployment with Gunicorn\n- Added .gitignore for Python project\n\n## Known Issues\n- ML model shows version warnings (trained with scikit-learn 1.5.2, running on 1.7.2)\n  - This is non-critical and doesn't affect functionality\n  - Consider retraining model with current version if needed\n\n## Notes\n- The application is designed for properties in Prabumulih, South Sumatra, Indonesia\n- Uses Indonesian language (Bahasa Indonesia) for the interface\n- Implements ProxyFix middleware for proper handling in Replit environment\n","size_bytes":3787}},"version":1}